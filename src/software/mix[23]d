../aax_audioframe.c: * Copyright 2011-2014 by Erik Hofman.
../aax_audioframe.c: * Copyright 2011-2014 by Adalin B.V.
../aax_audioframe.c:         frame->id = AUDIOFRAME_ID;
../aax_audioframe.c:         frame->cache_pos = UINT_MAX;
../aax_audioframe.c:         frame->mixer_pos = UINT_MAX;
../aax_audioframe.c:         frame->submix = submix;
../aax_audioframe.c:         submix->props2d = (_aax2dProps*)ptr2;
../aax_audioframe.c:         _aaxSetDefault2dProps(submix->props2d);
../aax_audioframe.c:         _EFFECT_SET2D(submix, PITCH_EFFECT, AAX_PITCH, handle->info->pitch);
../aax_audioframe.c:         submix->props3d = _aax3dPropsCreate();
../aax_audioframe.c:         if (submix->props3d)
../aax_audioframe.c:            dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_audioframe.c:               _aaxAudioFrame* smixer = sensor->mixer;
../aax_audioframe.c:               submix->info = sensor->mixer->info;
../aax_audioframe.c:         res = _intBufCreate(&submix->emitters_3d, _AAX_EMITTER);
../aax_audioframe.c:            res = _intBufCreate(&submix->emitters_2d, _AAX_EMITTER);
../aax_audioframe.c:            res = _intBufCreate(&submix->play_ringbuffers, _AAX_RINGBUFFER);
../aax_audioframe.c:            res = _intBufCreate(&submix->frame_ringbuffers, _AAX_RINGBUFFER);
../aax_audioframe.c:      } else if (handle->handle) {
../aax_audioframe.c:      _aaxAudioFrame* fmixer = handle->submix;
../aax_audioframe.c:      if (effect) free(effect->history_ptr);
../aax_audioframe.c:      _intBufErase(&fmixer->p3dq, _AAX_DELAYED3D, _aax_aligned_free);
../aax_audioframe.c:      _aax_aligned_free(fmixer->props3d->dprops3d);
../aax_audioframe.c:      free(fmixer->props3d);
../aax_audioframe.c:      /* handle->ringbuffer gets removed bij the frame thread */
../aax_audioframe.c:      /* be->destroy_ringbuffer(handle->ringbuffer); */
../aax_audioframe.c:      _intBufErase(&fmixer->frames, _AAX_FRAME, free);
../aax_audioframe.c:      _intBufErase(&fmixer->devices, _AAX_DEVICE, free);
../aax_audioframe.c:      _intBufErase(&fmixer->emitters_2d, _AAX_EMITTER, free);
../aax_audioframe.c:      _intBufErase(&fmixer->emitters_3d, _AAX_EMITTER, free);
../aax_audioframe.c:      _intBufErase(&fmixer->play_ringbuffers, _AAX_RINGBUFFER,
../aax_audioframe.c:      _intBufErase(&fmixer->frame_ringbuffers, _AAX_RINGBUFFER,
../aax_audioframe.c:      handle->id = FADEDBAD;
../aax_audioframe.c:      _aaxAudioFrame* fmixer = handle->submix;
../aax_audioframe.c:      _handle_t *parent = handle->handle;
../aax_audioframe.c:      if (parent && parent->id == HANDLE_ID)
../aax_audioframe.c:         dptr = _intBufGet(parent->sensors, _AAX_SENSOR, 0);
../aax_audioframe.c:            mtx4Copy(fmixer->props3d->m_dprops3d->matrix,
../aax_audioframe.c:                     sensor->mixer->props3d->m_dprops3d->matrix);
../aax_audioframe.c:      else if (parent && parent->id == AUDIOFRAME_ID)
../aax_audioframe.c:         _frame_t *parent = (_frame_t*)handle->handle;
../aax_audioframe.c:         mtx4Copy(fmixer->props3d->m_dprops3d->matrix,
../aax_audioframe.c:                  parent->submix->props3d->m_dprops3d->matrix);
../aax_audioframe.c:      mtx4Copy(fmixer->props3d->dprops3d->matrix, mtx);
../aax_audioframe.c:         fmixer->props3d->dprops3d->matrix[LOCATION][3] = 0.0f;
../aax_audioframe.c:         fmixer->props3d->dprops3d->velocity[VELOCITY][3] = 0.0f;
../aax_audioframe.c:         fmixer->props3d->dprops3d->matrix[LOCATION][3] = 1.0f;
../aax_audioframe.c:         fmixer->props3d->dprops3d->velocity[VELOCITY][3] = 1.0f;
../aax_audioframe.c:      _PROP_MTX_SET_CHANGED(fmixer->props3d);
../aax_audioframe.c:      mtx4Copy(mtx, handle->submix->props3d->dprops3d->matrix);
../aax_audioframe.c:      dp3d = handle->submix->props3d->dprops3d;
../aax_audioframe.c:      vec3Copy(dp3d->velocity[VELOCITY], velocity);
../aax_audioframe.c:      _PROP_SPEED_SET_CHANGED(handle->submix->props3d);
../aax_audioframe.c:      dp3d = handle->submix->props3d->dprops3d;
../aax_audioframe.c:      vec3Copy(velocity, dp3d->velocity[VELOCITY]);
../aax_audioframe.c:         _aaxAudioFrame* fmixer = handle->submix;
../aax_audioframe.c:            rv = 256*32768*lfo->compression[track];
../aax_audioframe.c:         _aaxAudioFrame* fmixer = handle->submix;
../aax_audioframe.c:         if (lfo && (lfo->average[track] <= lfo->gate_threshold)) {
../aax_audioframe.c:      int type = filter->pos;
../aax_audioframe.c:      switch (filter->type)
../aax_audioframe.c:         _aax2dProps *p2d = handle->submix->props2d;
../aax_audioframe.c:         _aax2dProps *p2d = handle->submix->props2d;
../aax_audioframe.c:         if (filter->type == AAX_DYNAMIC_GAIN_FILTER ||
../aax_audioframe.c:             filter->type == AAX_COMPRESSOR) {
../aax_audioframe.c:            p2d->final.gain_lfo = 1.0f;
../aax_audioframe.c:         _aax3dProps *p3d = handle->submix->props3d;
../aax_audioframe.c:         _aaxAudioFrame* submix = handle->submix;
../aax_audioframe.c:         rv = new_filter_handle(submix->info, type, submix->props2d,
../aax_audioframe.c:                                                    submix->props3d);
../aax_audioframe.c:      _aaxAudioFrame* fmixer = handle->submix;
../aax_audioframe.c:      int type = effect->pos;
../aax_audioframe.c:      switch (effect->type)
../aax_audioframe.c:         _aax2dProps *p2d = fmixer->props2d;
../aax_audioframe.c:         if ((enum aaxEffectType)effect->type == AAX_DYNAMIC_PITCH_EFFECT) {
../aax_audioframe.c:            p2d->final.pitch_lfo = 1.0f;
../aax_audioframe.c:         _aaxAudioFrame* fmixer = handle->submix;
../aax_audioframe.c:         rv = new_effect_handle(fmixer->info, type, fmixer->props2d,
../aax_audioframe.c:                                                    fmixer->props3d);
../aax_audioframe.c:      _aaxAudioFrame* fmixer = handle->submix;
../aax_audioframe.c:               fmixer->props3d->dprops3d->matrix[LOCATION][3] = 0.0f;
../aax_audioframe.c:               fmixer->props3d->dprops3d->matrix[LOCATION][3] = 1.0f;
../aax_audioframe.c:      } else if (!ssr_config || ssr_config->thread.started) {
../aax_audioframe.c:      } else if (ssr_config->mixer_pos < UINT_MAX) {
../aax_audioframe.c:      _aaxAudioFrame* fmixer = handle->submix;
../aax_audioframe.c:      _intBuffers *hd = fmixer->devices;
../aax_audioframe.c:         res = _intBufCreate(&fmixer->devices, _AAX_DEVICE);
../aax_audioframe.c:            hd = fmixer->devices;
../aax_audioframe.c:      if (hd && (fmixer->no_registered < fmixer->info->max_registered))
../aax_audioframe.c:         fmixer->no_registered++;
../aax_audioframe.c:         dptr = _intBufGet(ssr_config->sensors, _AAX_SENSOR, 0);
../aax_audioframe.c:            smixer = sensor->mixer;
../aax_audioframe.c:            mp3d = fmixer->props3d;
../aax_audioframe.c:            sp3d = smixer->props3d;
../aax_audioframe.c:            smixer->info->frequency = fmixer->info->frequency;
../aax_audioframe.c:            while (smixer->info->frequency > 48000.0f) {
../aax_audioframe.c:               smixer->info->frequency /= 2.0f;
../aax_audioframe.c:            smixer->info->period_rate = fmixer->info->period_rate;
../aax_audioframe.c:            smixer->info->refresh_rate = fmixer->info->refresh_rate;
../aax_audioframe.c:            smixer->info->update_rate = fmixer->info->update_rate;
../aax_audioframe.c:            ssr_config->handle = handle;
../aax_audioframe.c:            ssr_config->mixer_pos = pos;
../aax_audioframe.c:            smixer->refcount++;
../aax_audioframe.c:            if (!smixer->ringbuffer)
../aax_audioframe.c:               const _aaxDriverBackend *be = driver->backend.ptr;
../aax_audioframe.c:               enum aaxRenderMode mode = driver->info->mode;
../aax_audioframe.c:               smixer->ringbuffer = be->get_ringbuffer(dt, mode);
../aax_audioframe.c:            rb = smixer->ringbuffer;
../aax_audioframe.c:               _aaxMixerInfo* info = smixer->info;
../aax_audioframe.c:               float delay_sec = 1.0f / info->period_rate;
../aax_audioframe.c:               rb->set_format(rb, AAX_PCM24S, AAX_TRUE);
../aax_audioframe.c:               rb->set_paramf(rb, RB_FREQUENCY, info->frequency);
../aax_audioframe.c:               rb->set_parami(rb, RB_NO_TRACKS, 2);
../aax_audioframe.c:               rb->set_paramf(rb, RB_DURATION_SEC, delay_sec*1.0f);
../aax_audioframe.c:               rb->init(rb, AAX_TRUE);
../aax_audioframe.c:               rb->set_paramf(rb, RB_DURATION_SEC, delay_sec);
../aax_audioframe.c:               rb->set_state(rb, RB_STARTED);
../aax_audioframe.c:      } else if (!ssr_config || ssr_config->mixer_pos == UINT_MAX) {
../aax_audioframe.c:      _intBuffers *hd = handle->submix->devices;
../aax_audioframe.c:      ptr = _intBufRemove(hd, _AAX_DEVICE, ssr_config->mixer_pos, AAX_FALSE);
../aax_audioframe.c:         handle->submix->no_registered--;
../aax_audioframe.c:         dptr = _intBufGet(ssr_config->sensors, _AAX_SENSOR, 0);
../aax_audioframe.c:            sensor->mixer->refcount--;
../aax_audioframe.c:            ssr_config->mixer_pos = UINT_MAX;
../aax_audioframe.c:            ssr_config->handle = NULL;
../aax_audioframe.c:      } else if (!emitter || emitter->handle || emitter->mixer_pos < UINT_MAX) {
../aax_audioframe.c:      _aaxAudioFrame* fmixer = handle->submix;
../aax_audioframe.c:      _aaxEmitter *src = emitter->source;
../aax_audioframe.c:      positional = _IS_POSITIONAL(src->props3d);
../aax_audioframe.c:         he = fmixer->emitters_2d;
../aax_audioframe.c:         he = fmixer->emitters_3d;
../aax_audioframe.c:      if (fmixer->no_registered < fmixer->info->max_registered)
../aax_audioframe.c:            fmixer->no_registered++;
../aax_audioframe.c:         _aaxEmitter *src = emitter->source;
../aax_audioframe.c:         emitter->handle = handle;
../aax_audioframe.c:         emitter->mixer_pos = pos;
../aax_audioframe.c:            aaxFilterSetState(f, filter->slot[0]->state);
../aax_audioframe.c:         src->info = fmixer->info;
../aax_audioframe.c:         if (src->update_rate == 0) {
../aax_audioframe.c:            src->update_rate = fmixer->info->update_rate;
../aax_audioframe.c:         src->update_ctr = src->update_rate;
../aax_audioframe.c:            _aax3dProps *ep3d = src->props3d;
../aax_audioframe.c:            _aax3dProps *mp3d = fmixer->props3d;
../aax_audioframe.c:      } else if (!emitter || emitter->mixer_pos == UINT_MAX) {
../aax_audioframe.c:      _aaxAudioFrame* fmixer = handle->submix;
../aax_audioframe.c:      _aaxEmitter *src = emitter->source;
../aax_audioframe.c:      if (_IS_POSITIONAL(src->props3d))
../aax_audioframe.c:         he = fmixer->emitters_3d;
../aax_audioframe.c:         _PROP_DISTQUEUE_CLEAR_DEFINED(src->props3d);
../aax_audioframe.c:         he = fmixer->emitters_2d;
../aax_audioframe.c:      _intBufRelease(he, _AAX_EMITTER, emitter->mixer_pos);
../aax_audioframe.c:      _intBufRemove(he, _AAX_EMITTER, emitter->mixer_pos, AAX_FALSE);
../aax_audioframe.c:      fmixer->no_registered--;
../aax_audioframe.c:      emitter->mixer_pos = UINT_MAX;
../aax_audioframe.c:      emitter->handle = NULL;
../aax_audioframe.c:      } else if (!sframe || sframe->handle) {
../aax_audioframe.c:      } else if (sframe->mixer_pos < UINT_MAX) {
../aax_audioframe.c:      _aaxAudioFrame *fmixer =  handle->submix;
../aax_audioframe.c:      _intBuffers *hf = fmixer->frames;
../aax_audioframe.c:         res = _intBufCreate(&fmixer->frames, _AAX_FRAME);
../aax_audioframe.c:            hf = fmixer->frames;
../aax_audioframe.c:      if (hf && (fmixer->no_registered < fmixer->info->max_registered))
../aax_audioframe.c:         fmixer->no_registered++;
../aax_audioframe.c:         _aaxAudioFrame *submix = sframe->submix;
../aax_audioframe.c:            mp3d = fmixer->props3d;
../aax_audioframe.c:            fp3d = submix->props3d;
../aax_audioframe.c:            submix->refcount++;
../aax_audioframe.c:            sframe->handle = handle;
../aax_audioframe.c:            sframe->mixer_pos = pos;
../aax_audioframe.c:   if (sframe->handle) put_frame(sframe);
../aax_audioframe.c:      } else if (!sframe || sframe->mixer_pos == UINT_MAX) {
../aax_audioframe.c:      _intBuffers *hf = handle->submix->frames;
../aax_audioframe.c:      _intBufRelease(hf, _AAX_FRAME, sframe->mixer_pos);
../aax_audioframe.c:      _intBufRemove(hf, _AAX_FRAME, sframe->mixer_pos, AAX_FALSE);
../aax_audioframe.c:      sframe->submix->refcount--;
../aax_audioframe.c:      sframe->mixer_pos = UINT_MAX;
../aax_audioframe.c:      sframe->handle = NULL;
../aax_audioframe.c:      handle->submix->no_registered--;
../aax_audioframe.c:      float duration = 0.0f, refrate = handle->submix->info->period_rate;
../aax_audioframe.c:      fmixer = handle->submix;
../aax_audioframe.c:         nbuf = _intBufGetNumNoLock(fmixer->play_ringbuffers, _AAX_RINGBUFFER);
../aax_audioframe.c:      _aaxAudioFrame* fmixer = handle->submix;
../aax_audioframe.c:      _intBuffers *ringbuffers = fmixer->play_ringbuffers;
../aax_audioframe.c:            buf->id = BUFFER_ID;
../aax_audioframe.c:            buf->ref_counter = 1;
../aax_audioframe.c:            buf->blocksize = 1;
../aax_audioframe.c:            buf->pos = 0;
../aax_audioframe.c:            buf->format = rb->get_parami(rb, RB_FORMAT);
../aax_audioframe.c:            buf->frequency = rb->get_paramf(rb, RB_FREQUENCY);
../aax_audioframe.c:            buf->mipmap = AAX_FALSE;
../aax_audioframe.c:            buf->info = &_info;
../aax_audioframe.c:            rb->set_parami(rb, RB_IS_MIXER_BUFFER, AAX_FALSE);
../aax_audioframe.c:            buf->ringbuffer = rb;
../aax_audioframe.c:/* -------------------------------------------------------------------------- */
../aax_audioframe.c:   if (frame && (frame->id == AUDIOFRAME_ID))
../aax_audioframe.c:      _handle_t *handle = frame->handle;
../aax_audioframe.c:      if (handle && handle->id == HANDLE_ID)
../aax_audioframe.c:         _intBufferData *dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_audioframe.c:            _aaxAudioFrame* smixer = sensor->mixer;
../aax_audioframe.c:            hf = smixer->frames;
../aax_audioframe.c:            dptr_frame = _intBufGet(hf, _AAX_FRAME, frame->mixer_pos);
../aax_audioframe.c:      else if (handle && handle->id == AUDIOFRAME_ID)
../aax_audioframe.c:         _frame_t *handle = (_frame_t*)frame->handle;
../aax_audioframe.c:         hf =  handle->submix->frames;
../aax_audioframe.c:         dptr_frame = _intBufGet(hf, _AAX_FRAME, frame->mixer_pos);
../aax_audioframe.c:   if (frame && (frame->id == AUDIOFRAME_ID))
../aax_audioframe.c:      _handle_t *handle = frame->handle;
../aax_audioframe.c:      if (handle && handle->id == HANDLE_ID)
../aax_audioframe.c:          _intBufferData *dptr =_intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_audioframe.c:            _aaxAudioFrame* smixer = sensor->mixer;
../aax_audioframe.c:            hf = smixer->frames;
../aax_audioframe.c:            _intBufRelease(hf, _AAX_FRAME, frame->mixer_pos);
../aax_audioframe.c:      else if (handle && handle->id == AUDIOFRAME_ID)
../aax_audioframe.c:         _frame_t *handle = (_frame_t*)frame->handle;
../aax_audioframe.c:         hf =  handle->submix->frames;
../aax_audioframe.c:         _intBufRelease(hf, _AAX_FRAME, frame->mixer_pos);
../aax_audioframe.c:      if (frame->id == HANDLE_ID) {
../aax_audioframe.c:      } else if (frame->id == AUDIOFRAME_ID) {
../aax_audioframe.c:         rv = frame->submix->info->backend;
../aax_audioframe.c:   dist_delaying = _FILTER_GET_STATE(frame->props3d, DISTANCE_FILTER);
../aax_audioframe.c:   dist_delaying |= _FILTER_GET_STATE(mixer->props3d, DISTANCE_FILTER);
../aax_audioframe.c:      _aax3dProps *pp3d = mixer->props3d;
../aax_audioframe.c:      _aaxDelayed3dProps *pdp3d_m = pp3d->m_dprops3d;
../aax_audioframe.c:      _aax3dProps *fp3d = frame->props3d;
../aax_audioframe.c:      _aaxDelayed3dProps *fdp3d_m = fp3d->m_dprops3d;
../aax_audioframe.c:      _aaxDelayed3dProps *fdp3d = fp3d->dprops3d;
../aax_audioframe.c:      _aax2dProps *fp2d = frame->props2d;
../aax_audioframe.c:      mtx4Mul(fdp3d_m->matrix, pdp3d_m->matrix, fdp3d->matrix);
../aax_audioframe.c:      dist = vec3Magnitude(fdp3d_m->matrix[LOCATION]);
../aax_audioframe.c:      fp2d->dist_delay_sec = dist / vs;
../aax_audioframe.c: PRINT_MATRICES(pdp3d_m->matrix, fdp3d->matrix);
../aax_audioframe.c: PRINT_MATRIX(fdp3d_m->matrix);
../aax_audioframe.c: printf("delay: %f, dist: %f, vs: %f\n", fp2d->dist_delay_sec, dist, vs);
../aax_audioframe.c:      _PROP_DISTQUEUE_SET_DEFINED(frame->props3d);
../aax_audioframe.c:      fp3d->buf3dq_step = 1.0f;
../aax_audioframe.c:      if (!frame->p3dq) {
../aax_audioframe.c:         _intBufCreate(&frame->p3dq, _AAX_DELAYED3D);
../aax_audioframe.c:         _intBufClear(frame->p3dq, _AAX_DELAYED3D, _aax_aligned_free);
../aax_audioframe.c:      frame->submix->capturing = AAX_TRUE;
../aax_buffer.c: * Copyright 2007-2014 by Erik Hofman.
../aax_buffer.c: * Copyright 2009-2014 by Adalin B.V.
../aax_buffer.c:         buf->id = BUFFER_ID;
../aax_buffer.c:         buf->ref_counter = 1;
../aax_buffer.c:         buf->no_tracks = tracks;
../aax_buffer.c:         buf->no_samples = samples;
../aax_buffer.c:         buf->blocksize = blocksize;
../aax_buffer.c:         buf->mipmap = AAX_FALSE;
../aax_buffer.c:         buf->pos = 0;
../aax_buffer.c:         buf->format = format;
../aax_buffer.c:         buf->frequency = 0.0f;
../aax_buffer.c:         buf->info = VALID_LITE_HANDLE(handle) ? &handle->info : &_info;
../aax_buffer.c:         buf->ringbuffer = _bufGetRingBuffer(buf, handle);
../aax_buffer.c:            if (rb && !buf->frequency) {
../aax_buffer.c:               rb->set_paramf(rb, RB_FREQUENCY, (float)setup);
../aax_buffer.c:            buf->frequency = (float)setup;
../aax_buffer.c:               rv = rb->set_parami(rb, RB_NO_TRACKS, setup);
../aax_buffer.c:            buf->no_tracks = setup;
../aax_buffer.c:            buf->format = setup;
../aax_buffer.c:               buf->blocksize = DEFAULT_IMA4_BLOCKSIZE;
../aax_buffer.c:               buf->blocksize = 1;
../aax_buffer.c:            rv = rb->set_parami(rb, RB_TRACKSIZE, setup);
../aax_buffer.c:         tmp = buf->no_tracks * aaxGetBitsPerSample(buf->format);
../aax_buffer.c:         buf->no_samples = setup*8/tmp;
../aax_buffer.c:         if (setup < buf->no_samples)
../aax_buffer.c:               int looping = (setup < buf->loop_end) ? AAX_TRUE : AAX_FALSE;
../aax_buffer.c:               rb->set_parami(rb, RB_LOOPPOINT_START, setup);
../aax_buffer.c:               rb->set_parami(rb, RB_LOOPING, looping);
../aax_buffer.c:            buf->loop_start = setup;
../aax_buffer.c:         if (setup < buf->no_samples)
../aax_buffer.c:               int looping = (buf->loop_start < setup) ? AAX_TRUE : AAX_FALSE;
../aax_buffer.c:               rb->set_parami(rb, RB_LOOPPOINT_END, setup);
../aax_buffer.c:               rb->set_parami(rb, RB_LOOPING, looping);
../aax_buffer.c:            buf->loop_end = setup;
../aax_buffer.c:            if (buf->format == AAX_IMA4_ADPCM)
../aax_buffer.c:               buf->blocksize = setup;
../aax_buffer.c:         else if (buf->format != AAX_IMA4_ADPCM)
../aax_buffer.c:            buf->blocksize = setup;
../aax_buffer.c:         if (setup <= buf->no_samples)
../aax_buffer.c:            buf->pos = setup;
../aax_buffer.c:         rv = (unsigned int)buf->frequency;
../aax_buffer.c:         rv = buf->no_tracks;
../aax_buffer.c:         rv = buf->format;
../aax_buffer.c:         if (buf->frequency)
../aax_buffer.c:               fact = buf->frequency / rb->get_paramf(rb, RB_FREQUENCY);
../aax_buffer.c:            rv = buf->no_samples - buf->pos;
../aax_buffer.c:            rv *= (unsigned int)(fact*aaxGetBitsPerSample(buf->format));
../aax_buffer.c:          if (buf->frequency)
../aax_buffer.c:               fact = buf->frequency / rb->get_paramf(rb, RB_FREQUENCY);
../aax_buffer.c:            rv = (unsigned int)(fact*(buf->no_samples - buf->pos));
../aax_buffer.c:         rv = buf->loop_start;
../aax_buffer.c:         rv = buf->loop_end;
../aax_buffer.c:         rv = buf->blocksize;
../aax_buffer.c:         rv = buf->pos;
../aax_buffer.c:   if (buf && (buf->format & AAX_SPECIAL) && d)
../aax_buffer.c:      unsigned int format = buf->format;
../aax_buffer.c:         rb->init(rb, AAX_FALSE);
../aax_buffer.c:         tracks = rb->get_parami(rb, RB_NO_TRACKS);
../aax_buffer.c:         no_samples = rb->get_parami(rb, RB_NO_SAMPLES);
../aax_buffer.c:            unsigned blocksize =  buf->blocksize;
../aax_buffer.c:            unsigned int format = buf->format;
../aax_buffer.c:   if (buf && buf->frequency)
../aax_buffer.c:      fact = buf->frequency / rb->get_paramf(rb, RB_FREQUENCY);
../aax_buffer.c:      pos = (unsigned int)(fact*buf->pos);
../aax_buffer.c:      no_samples = (unsigned int)(fact*rb->get_parami(rb, RB_NO_SAMPLES) - pos);
../aax_buffer.c:      bps = rb->get_parami(rb, RB_BYTES_SAMPLE);
../aax_buffer.c:      tracks = rb->get_parami(rb, RB_NO_TRACKS);
../aax_buffer.c:      user_format = buf->format;
../aax_buffer.c:      rb_format = rb->get_parami(rb, RB_FORMAT);
../aax_buffer.c:         if (rb_format != AAX_PCM24S) 	/* first convert to signed 24-bit */
../aax_buffer.c:            int block_smp = BLOCKSIZE_TO_SMP(buf->blocksize);
../aax_buffer.c:                                         native_fmt, buf->blocksize);
../aax_buffer.c:			/* do we need to convert to non-native format? */
../aax_buffer.c:   else if (buf) {	/* buf->frequency is not set */
../aax_buffer.c:      _aaxRingBufferSample *rbd = rb->sample;
../aax_buffer.c:      data = (const int32_t**)rbd->track;
../aax_buffer.c:      format = buf->format;
../aax_buffer.c:      freq = buf->frequency;
../aax_buffer.c:/* -------------------------------------------------------------------------- */
../aax_buffer.c:  1,    /* 8-bit          */
../aax_buffer.c:  2,    /* 16-bit         */
../aax_buffer.c:  4,    /* 24-bit         */
../aax_buffer.c:  4,    /* 32-bit         */
../aax_buffer.c:  4,    /* 32-bit floats  */
../aax_buffer.c:  8,    /* 64-bit doubles */
../aax_buffer.c:  1,    /* mu-law         */
../aax_buffer.c:  1,    /* a-law          */
../aax_buffer.c:  1     /* IMA4-ADPCM     */
../aax_buffer.c:   if (handle && handle->id == BUFFER_ID) {
../aax_buffer.c:      if (--buf->ref_counter == 0)
../aax_buffer.c:         buf->ringbuffer = _bufDestroyRingBuffer(buf);
../aax_buffer.c:         buf->id = FADEDBAD;
../aax_buffer.c:   _aaxRingBuffer *rb = buf->ringbuffer;
../aax_buffer.c:               (buf->info && *buf->info &&
../aax_buffer.c:                VALID_LITE_HANDLE((_handle_t*)((*buf->info)->backend)))
../aax_buffer.c:      enum aaxRenderMode mode = handle->info->mode;
../aax_buffer.c:         be = handle->backend.ptr;
../aax_buffer.c:         be = ((_handle_t*)((*buf->info)->backend))->backend.ptr;
../aax_buffer.c:      rb = be->get_ringbuffer(0.0f, mode);
../aax_buffer.c:         rb->set_format(rb, buf->format & AAX_FORMAT_NATIVE, AAX_FALSE);
../aax_buffer.c:         rb->set_parami(rb, RB_NO_TRACKS, buf->no_tracks);
../aax_buffer.c:         rb->set_parami(rb, RB_NO_SAMPLES, buf->no_samples);
../aax_buffer.c:         rb->set_parami(rb, RB_LOOPPOINT_START, buf->loop_start);
../aax_buffer.c:         rb->set_parami(rb, RB_LOOPPOINT_END, buf->loop_end);
../aax_buffer.c:         rb->set_paramf(rb, RB_FREQUENCY, buf->frequency);
../aax_buffer.c://       rb->set_paramf(rb, RB_BLOCKSIZE, buf->blocksize);
../aax_buffer.c:          * rb->init(rb, AAX_FALSE);
../aax_buffer.c:   _aaxRingBuffer *rb = buf->ringbuffer;
../aax_buffer.c:   if (rb && (buf->info && *buf->info &&
../aax_buffer.c:              VALID_LITE_HANDLE((_handle_t*)((*buf->info)->backend)))
../aax_buffer.c:      _handle_t *handle = (_handle_t*)(*buf->info)->backend;
../aax_buffer.c:      const _aaxDriverBackend *be = handle->backend.ptr;
../aax_buffer.c:      be->destroy_ringbuffer(rb);
../aax_buffer.c:               if (!xmlAttributeCompareString(xwid, "src", "brownian-noise")) 
../aax_buffer.c:               else if (!xmlAttributeCompareString(xwid, "src", "white-noise"))
../aax_buffer.c:               else if (!xmlAttributeCompareString(xwid, "src", "pink-noise")) 
../aax_buffer.c://       rb->limit(rb, RB_LIMITER_ELECTRONIC);
../aax_buffer.c:   } else if (ratio > 1.0f || ratio < -1.0f) {
../aax_buffer.c:   else if (buf && buf->info && (*buf->info && ((*buf->info)->id == INFO_ID)))
../aax_buffer.c:      fs = rb->get_paramf(rb, RB_FREQUENCY);
../aax_buffer.c:      no_samples = rb->get_parami(rb, RB_NO_SAMPLES);
../aax_buffer.c:      if (rb->get_state(rb, RB_IS_VALID) == AAX_FALSE)
../aax_buffer.c:          rb->set_parami(rb, RB_NO_SAMPLES, no_samples);
../aax_buffer.c:          rb->init(rb, AAX_FALSE);
../aax_buffer.c:         rb->set_state(rb, RB_CLEARED);
../aax_buffer.c:         float ratio_orig = FNMINMAX(1.0f-ratio, 0.0f, 1.0f);
../aax_buffer.c:         ratio = 2.0f*(1.0f - ratio_orig);
../aax_buffer.c:         rb->data_multiply(rb, 0, 0, ratio_orig);
../aax_buffer.c:         ratio = -ratio;
../aax_buffer.c:      if (buf->info && *buf->info) {
../aax_buffer.c:         fs_mixer = (*buf->info)->frequency;
../aax_buffer.c:            rv = rb->data_mix_waveform(rb, wtype & bit, f, ratio, phase);
../aax_buffer.c:            rv = rb->data_mix_noise(rb, wtype & bit, fs_mixer, pitch, ratio, dc, skip);
../aax_buffer.c: * Convert the buffer to 24-bit
../aax_buffer.c:   } while (--i);
../aax_buffer.c:   } while (--i);
../aax_buffer.c:   } while (--i);
../aax_buffer.c:   } while (--i);
../aax_buffer.c: * Incompatible with MS-IMA which specifies a different way of interleaving.
../aax_buffer.c:      unsigned int rest = (no_blocks+1)*block_smp - samples;
../aax_buffer.c:      samples = block_smp - rest;
../aax_buffer.c: * Convert 4-bit IMA to 16-bit PCM
../aax_buffer.c:   i = blocks-1;
../aax_buffer.c:   while (--i);
../aax_buffer.c:   no_samples -= blocks*block_smp;
../aax_buffer.c:   rb->set_state(rb, RB_CLEARED);
../aax_buffer.c:   rb->set_parami(rb, RB_LOOPING, looping);
../aax_buffer.c:   fmt = rb->get_parami(rb, RB_FORMAT);
../aax_buffer.c:   bps = rb->get_parami(rb, RB_BYTES_SAMPLE);
../aax_buffer.c:   no_samples = rb->get_parami(rb, RB_NO_SAMPLES);
../aax_buffer.c:   no_tracks = rb->get_parami(rb, RB_NO_TRACKS);
../aax_buffer.c:   tracks = (int32_t**)rb->get_tracks_ptr(rb, RB_WRITE);
../aax_buffer.c:            while (--i);
../aax_buffer.c:   rb->release_tracks_ptr(rb);
../aax_buffer.c:   fmt = rb->get_parami(rb, RB_FORMAT);
../aax_buffer.c:   bps = rb->get_parami(rb, RB_BYTES_SAMPLE);
../aax_buffer.c:   no_samples = rb->get_parami(rb, RB_NO_SAMPLES);
../aax_buffer.c:   no_tracks = rb->get_parami(rb, RB_NO_TRACKS);
../aax_buffer.c:   tracks = (void**)rb->get_tracks_ptr(rb, RB_NONE);
../aax_buffer.c:            if (rb->get_parami(rb, RB_IS_MIXER_BUFFER) == AAX_FALSE) {
../aax_buffer.c:         while (--i);
../aax_buffer.c:   rb->release_tracks_ptr(rb);
../aax_driver.c: * Copyright 2007-2014 by Erik Hofman.
../aax_driver.c: * Copyright 2009-2014 by Adalin B.V.
../aax_driver.c:      const _aaxDriverBackend *be = handle->backend.ptr;
../aax_driver.c:         if (handle->backend.driver) {
../aax_driver.c:            rv = (char*)be->renderer;
../aax_driver.c:            rv = (char*)be->driver;
../aax_driver.c:         if (handle->backend.driver) {
../aax_driver.c:            rv = (char*)handle->backend.driver;
../aax_driver.c:            rv = (char*)be->driver;
../aax_driver.c:         rv = (char*)be->version;
../aax_driver.c:         rv = (char*)be->vendor;
../aax_driver.c:          rv = be->name(handle->backend.handle, type);
../aax_driver.c:            if (!m && be->state(NULL, DRIVER_SUPPORTS_CAPTURE)) rv++;
../aax_driver.c:            else if (m && be->state(NULL, DRIVER_SUPPORTS_PLAYBACK)) rv++;
../aax_driver.c:         unsigned count = _intBufGetNumNoLock(handle->backends, _AAX_BACKEND);
../aax_driver.c:            be = _aaxGetDriverBackendByPos(handle->backends, i);
../aax_driver.c:               if ((!m && be->state(NULL, DRIVER_SUPPORTS_CAPTURE)) &&
../aax_driver.c:               else if ((m && be->state(NULL, DRIVER_SUPPORTS_PLAYBACK)) &&
../aax_driver.c:            handle->id = HANDLE_ID;
../aax_driver.c:            handle->backend.ptr = be;
../aax_driver.c:            handle->info->mode = mode;
../aax_driver.c://          handle->devname[0] = be->driver;
../aax_driver.c:            handle->devname[0] = (char *)_aax_default_devname;
../aax_driver.c:         handle->info->mode = mode;
../aax_driver.c:            if (cfg->node[0].devname) {
../aax_driver.c:               name = _aax_strdup(cfg->node[0].devname);
../aax_driver.c:               handle->backend.driver = _aax_strdup(cfg->node[0].devname);
../aax_driver.c:            handle->devname[0] = _aax_strdup(name);
../aax_driver.c:            ptr = strstr(handle->devname[0], " on ");
../aax_driver.c:               handle->devname[1] = ptr+4;	/* 4 = strlen(" on ") */
../aax_driver.c:               if (!strcasecmp(handle->devname[0], "Generic Software") ||
../aax_driver.c:                   !strcasecmp(handle->devname[0], "Generic Hardware"))
../aax_driver.c:                  sprintf(handle->devname[0], "WASAPI");
../aax_driver.c:                  _aaxConnectorDeviceToDeviceConnector(handle->devname[1]);
../aax_driver.c:            handle->backend.ptr = _aaxGetDriverBackendByName(handle->backends,
../aax_driver.c:                                                            handle->devname[0],
../aax_driver.c:                                                            &handle->be_pos);
../aax_driver.c:               be = _aaxGetDriverBackendDefaultCapture(handle->backends,
../aax_driver.c:                                                       &handle->be_pos);
../aax_driver.c:               be = _aaxGetDriverBackendDefault(handle->backends,
../aax_driver.c:                                                &handle->be_pos);
../aax_driver.c:            handle->backend.ptr = be;
../aax_driver.c:               handle->devname[0] = _aax_strdup(be->driver);
../aax_driver.c:               handle->devname[1] = be->name(handle->backend.handle, mode);
../aax_driver.c:         if (handle->backend.ptr == NULL)
../aax_driver.c:            if (handle->devname[0] != _aax_default_devname)
../aax_driver.c:               free(handle->devname[0]);
../aax_driver.c:               handle->devname[0] = (char *)_aax_default_devname;
../aax_driver.c:      const _aaxDriverBackend *be = handle->backend.ptr;
../aax_driver.c:         rv = be->state(NULL, DRIVER_SUPPORTS_CAPTURE);
../aax_driver.c:         rv = be->state(NULL, DRIVER_SUPPORTS_PLAYBACK);
../aax_driver.c:      enum aaxRenderMode mode = handle->info->mode;
../aax_driver.c:      const _aaxDriverBackend *be = handle->backend.ptr;
../aax_driver.c:         if (handle->info->mode == AAX_MODE_READ) {
../aax_driver.c:            xoid = cfg->backend.input;
../aax_driver.c:            xoid = cfg->backend.output;
../aax_driver.c:            const char* name = handle->devname[1];
../aax_driver.c:            handle->backend.handle = be->connect(nid, xoid, name, mode);
../aax_driver.c:            if (handle->backend.driver != _default_renderer) {
../aax_driver.c:               free(handle->backend.driver);
../aax_driver.c:            renderer = be->name(handle->backend.handle, mode);
../aax_driver.c:            handle->backend.driver = malloc(strlen(be->driver)
../aax_driver.c:            if (handle->backend.driver)
../aax_driver.c:               sprintf(handle->backend.driver, "%s on %s", be->driver,renderer);
../aax_driver.c:                handle->backend.driver = renderer;
../aax_driver.c:               _info =  handle->info;
../aax_driver.c:            if (handle->info->mode == AAX_MODE_WRITE_SURROUND)
../aax_driver.c:   if (!handle || !handle->backend.handle)
../aax_driver.c:   if (handle && !handle->handle)
../aax_driver.c:      assert(handle->backends != NULL);
../aax_driver.c:      _aaxSignalFree(&handle->buffer_ready);
../aax_driver.c:      handle->info->id = FADEDBAD;
../aax_driver.c:      if (_info == handle->info) {
../aax_driver.c:      _intBufErase(&handle->sensors, _AAX_SENSOR, _aaxFreeSensor);
../aax_driver.c:      if (handle->devname[0] != _aax_default_devname)
../aax_driver.c:         free(handle->devname[0]);
../aax_driver.c:         handle->devname[0] = (char *)_aax_default_devname;
../aax_driver.c:      if (handle->backend.driver != _default_renderer) {
../aax_driver.c:         free(handle->backend.driver);
../aax_driver.c:      if (handle->ringbuffer) {
../aax_driver.c:         _aaxRingBufferFree(handle->ringbuffer);
../aax_driver.c:      if (handle->timer) {
../aax_driver.c:         _aaxTimerDestroy(handle->timer);
../aax_driver.c:      handle->id = FADEDBAD;
../aax_driver.c:   if (handle && handle->backend.handle)
../aax_driver.c:      const _aaxDriverBackend *be = handle->backend.ptr;
../aax_driver.c:      if (be && handle->backend.handle) {
../aax_driver.c:         be->disconnect(handle->backend.handle);
../aax_driver.c:      handle->backend.handle = NULL;
../aax_driver.c:         const _aaxDriverBackend *be = handle->backend.ptr;
../aax_driver.c:         void* be_handle = handle->backend.handle;
../aax_driver.c:         ptr = be->get_devices(be_handle, mode);
../aax_driver.c:         const _aaxDriverBackend *be = handle->backend.ptr;
../aax_driver.c:         void* be_handle = handle->backend.handle;
../aax_driver.c:         if (handle->be_pos != pos)
../aax_driver.c:            handle->be_pos = pos;
../aax_driver.c:            be_handle = be->new_handle(mode);
../aax_driver.c:            handle->backend.handle = be_handle;
../aax_driver.c:            if (handle->backend.driver != _default_renderer) {
../aax_driver.c:               free(handle->backend.driver);
../aax_driver.c:            renderer = be->name(handle->backend.handle, mode);
../aax_driver.c:            handle->backend.driver = renderer ? renderer : _default_renderer;
../aax_driver.c:         ptr = be->get_devices(be_handle, mode);
../aax_driver.c:         const _aaxDriverBackend *be = handle->backend.ptr;
../aax_driver.c:         void* be_handle = handle->backend.handle;
../aax_driver.c:         ptr = be->get_interfaces(be_handle, devname, mode);
../aax_driver.c:         const _aaxDriverBackend *be = handle->backend.ptr;
../aax_driver.c:         void* be_handle = handle->backend.handle;
../aax_driver.c:         ptr = be->get_interfaces(be_handle, devname, mode);
../aax_driver.c:/* -------------------------------------------------------------------------- */
../aax_driver.c:      handle->id = HANDLE_ID;
../aax_driver.c:      handle->backends = get_backends();
../aax_driver.c:      handle->mixer_pos = UINT_MAX;
../aax_driver.c:      handle->be_pos = UINT_MAX;
../aax_driver.c:      handle->info = (_aaxMixerInfo*)ptr2;
../aax_driver.c:      _aaxSetDefaultInfo(handle->info, handle);
../aax_driver.c:      handle->timer = _aaxTimerCreate();
../aax_driver.c:   if (handle && handle->id == HANDLE_ID) {
../aax_driver.c:      if (handle->id == HANDLE_ID)
../aax_driver.c:         if (handle->valid & ~HANDLE_ID) {
../aax_driver.c:      else if (handle->id == AUDIOFRAME_ID) {
../aax_driver.c:   if (handle && handle->id == HANDLE_ID)
../aax_driver.c:      assert(handle->info);
../aax_driver.c:      if (handle->info->mode != AAX_MODE_READ) {
../aax_driver.c:   if (handle && handle->id == HANDLE_ID)
../aax_driver.c:      assert(handle->info);
../aax_driver.c:      if (handle->info->mode == AAX_MODE_READ) {
../aax_driver.c:   if (handle && handle->id == HANDLE_ID)
../aax_driver.c:      assert (handle->backend.ptr != NULL);
../aax_driver.c:      if (handle->sensors == NULL)
../aax_driver.c:         unsigned int res = _intBufCreate(&handle->sensors, _AAX_SENSOR);
../aax_driver.c:               sensor->filter = handle->filter;
../aax_driver.c:               _aaxSetDefaultEqualizer(handle->filter);
../aax_driver.c:               sensor->mixer = smixer;
../aax_driver.c:               sensor->mixer->info = handle->info;
../aax_driver.c:               smixer->props2d = (_aax2dProps*)ptr2;
../aax_driver.c:               _aaxSetDefault2dProps(smixer->props2d);
../aax_driver.c:               _EFFECT_SET2D(smixer,PITCH_EFFECT,AAX_PITCH,handle->info->pitch);
../aax_driver.c:               smixer->props3d = _aax3dPropsCreate();
../aax_driver.c:               if (smixer->props3d)
../aax_driver.c:                  smixer->props3d->dprops3d->velocity[VELOCITY][3] = 0.0f;
../aax_driver.c:               res = _intBufCreate(&smixer->emitters_3d, _AAX_EMITTER);
../aax_driver.c:                  res = _intBufCreate(&smixer->emitters_2d, _AAX_EMITTER);
../aax_driver.c:                  res = _intBufCreate(&smixer->play_ringbuffers, _AAX_RINGBUFFER);
../aax_driver.c:                  res = _intBufAddData(handle->sensors,_AAX_SENSOR, sensor);
../aax_driver.c:                     sensor->count = 1;
../aax_driver.c:                     sensor->mixer->info->max_emitters = num;
../aax_driver.c:                     sensor->mixer->info->max_registered = num;
../aax_driver.c:                     _PROP_PITCH_SET_CHANGED(smixer->props3d);
../aax_driver.c:                     _PROP_MTX_SET_CHANGED(smixer->props3d);
../aax_driver.c:                     _aaxSignalInit(&handle->buffer_ready);
../aax_driver.c:                  _intBufErase(&smixer->play_ringbuffers, _AAX_RINGBUFFER, free);
../aax_driver.c:            _intBufErase(&handle->sensors, _AAX_SENSOR, _aaxFreeSensor);
../aax_driver.c:      tract_now = _aaxDriverBackendSetConfigSettings(handle->backends,
../aax_driver.c:                                                     handle->devname, config);
../aax_driver.c:            _aaxDriverBackendReadConfigSettings(xid, handle->devname, config,
../aax_driver.c:            _aaxDriverBackendReadConfigSettings(xid, handle->devname,
../aax_driver.c:         name = handle->devname[0];
../aax_driver.c:            else if (config->node[0].devname) {
../aax_driver.c:               name = strdup(config->node[0].devname);
../aax_driver.c:            handle->devname[0] = name;
../aax_driver.c:               handle->devname[1] = ptr+4;		/* 4 = strlen(" on ") */
../aax_driver.c:         be = _aaxGetDriverBackendByName(handle->backends, name,
../aax_driver.c:                                         &handle->be_pos);
../aax_driver.c:         if (be || (handle->devname[0] != _aax_default_devname)) {
../aax_driver.c:            handle->backend.ptr = be;
../aax_driver.c:         handle->backend.driver = _aax_strdup(config->backend.driver);
../aax_driver.c:         if (config->node[0].no_emitters)
../aax_driver.c:            unsigned int emitters = config->node[0].no_emitters;
../aax_driver.c:            handle->info->max_emitters = _MINMAX(emitters, 4, system_max);
../aax_driver.c:            _aaxSetNoEmitters(handle->info->max_emitters);
../aax_driver.c:            handle->info->max_emitters = _aaxGetNoEmitters();
../aax_driver.c:         ptr = config->node[0].setup;
../aax_driver.c:         if (ptr && handle->info->mode == AAX_MODE_WRITE_STEREO)
../aax_driver.c:               handle->info->mode = AAX_MODE_WRITE_SURROUND;
../aax_driver.c:               handle->info->mode = AAX_MODE_WRITE_HRTF;
../aax_driver.c:               handle->info->mode = AAX_MODE_WRITE_SPATIAL;
../aax_driver.c:               handle->info->mode = AAX_MODE_WRITE_STEREO;
../aax_driver.c:         else if (ptr && handle->info->mode == AAX_MODE_READ)
../aax_driver.c:               handle->info->track = AAX_TRACK_MIX;
../aax_driver.c:               handle->info->track = AAX_TRACK_LEFT;
../aax_driver.c:               handle->info->track = AAX_TRACK_RIGHT;
../aax_driver.c:               handle->info->track = AAX_TRACK_ALL;
../aax_driver.c:         if (config->node[0].no_speakers > 0) {
../aax_driver.c:            handle->info->no_tracks = config->node[0].no_speakers;
../aax_driver.c:         if (config->node[0].bitrate >= 64 && config->node[0].bitrate <= 320) {
../aax_driver.c:            handle->info->bitrate = config->node[0].bitrate;
../aax_driver.c:         fq = config->node[0].frequency;
../aax_driver.c:         iv = config->node[0].interval;
../aax_driver.c:            handle->info->period_rate = iv;
../aax_driver.c:            handle->info->refresh_rate = iv;
../aax_driver.c:            handle->info->frequency = fq;
../aax_driver.c:            if (config->node[0].update) {
../aax_driver.c:               handle->info->update_rate = (uint8_t)rintf(iv/config->node[0].update);
../aax_driver.c:               handle->info->update_rate = (uint8_t)rintf(iv/50);
../aax_driver.c:            if (handle->info->update_rate < 1) {
../aax_driver.c:               handle->info->update_rate = 1;
../aax_driver.c:            handle->valid = HANDLE_ID;
../aax_driver.c:            handle->info->period_rate = iv;
../aax_driver.c:            handle->info->refresh_rate = iv;
../aax_driver.c:            handle->info->frequency = fq;
../aax_driver.c:            if (config->node[0].update) {
../aax_driver.c:               handle->info->update_rate = (uint8_t)rintf(iv/config->node[0].update);
../aax_driver.c:               handle->info->update_rate = (uint8_t)rintf(iv/50);
../aax_driver.c:            if (handle->info->update_rate < 1) {
../aax_driver.c:               handle->info->update_rate = 1;
../aax_driver.c:            if (handle->info->max_emitters > _AAX_MAX_MIXER_REGISTERED_LT) {
../aax_driver.c:                handle->info->max_emitters =  _AAX_MAX_MIXER_REGISTERED_LT;
../aax_driver.c:            handle->info->max_registered = _AAX_MAX_MIXER_REGISTERED_LT;
../aax_driver.c:            _aaxSetNoEmitters(handle->info->max_emitters);
../aax_driver.c:            handle->valid = LITE_HANDLE_ID;
../aax_driver.c:         if (handle->sensors)
../aax_driver.c:            dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_driver.c:               _aaxMixerInfo* info = sensor->mixer->info;
../aax_driver.c:               if (handle->info->mode == AAX_MODE_WRITE_HRTF)
../aax_driver.c:                  handle->info->no_tracks = 2;
../aax_driver.c:                  _aax_memcpy(&info->speaker,&_aaxContextDefaultHRTFVolume, size);
../aax_driver.c:                  _aax_memcpy(info->delay, &_aaxContextDefaultHRTFDelay, size);
../aax_driver.c:                  _aaxContextSetupHRTF(config->node[0].hrtf, 0);
../aax_driver.c:                  vec4Copy(info->hrtf[0], _aaxContextDefaultHead[0]);
../aax_driver.c:                  vec4ScalarMul(info->hrtf[0], fq);
../aax_driver.c:                  vec4Copy(info->hrtf[1], _aaxContextDefaultHead[1]);
../aax_driver.c:                  vec4ScalarMul(info->hrtf[1], fq);
../aax_driver.c:                  _aaxContextSetupSpeakers(config->node[0].speaker, 
../aax_driver.c:                                           info->router, info->no_tracks);
../aax_driver.c:                  for (t=0; t<handle->info->no_tracks; t++)
../aax_driver.c:                     float gain = vec3Normalize(info->speaker[t],
../aax_driver.c:                     info->speaker[t][3] = 1.0f/gain;
../aax_driver.c:                  _aax_memcpy(info->delay, &_aaxContextDefaultSpeakersDelay, size);
../aax_driver.c:               for (i=0; i<config->no_nodes; i++)
../aax_driver.c:                  snprintf(buf,1024,"  output[%i]: '%s'\n", i, config->node[i].devname);
../aax_driver.c:                  snprintf(buf,1024,"  setup: %s\n", (handle->info->mode == AAX_MODE_READ) ? "capture" : config->node[i].setup);
../aax_driver.c:                           handle->info->frequency, handle->info->refresh_rate);
../aax_driver.c:                     snprintf(buf,1024,"  backend[%i]: '%s'\n", i, be->driver);
../aax_driver.c:      f = (float)xmlNodeGetDouble(xid, "side-delay-sec");
../aax_driver.c:      f = (float)xmlNodeGetDouble(xid, "side-offset-sec");
../aax_driver.c:      f = (float)xmlNodeGetDouble(xid, "up-delay-sec");
../aax_driver.c:      f = (float)xmlNodeGetDouble(xid, "up-offset-sec");
../aax_driver.c:      f = (float)xmlNodeGetDouble(xid, "forward-delay-sec");
../aax_driver.c:      f = (float)xmlNodeGetDouble(xid, "forward-offset-sec");
../aax_driver.c:         if (channel >= n) channel = n-1;
../aax_driver.c:         f = (float)xmlNodeGetDouble(xsid, "volume-norm");
../aax_driver.c:         v[0] = (float)xmlNodeGetDouble(xsid, "pos-x");
../aax_driver.c:         v[1] = -(float)xmlNodeGetDouble(xsid, "pos-y");
../aax_driver.c:         v[2] = (float)xmlNodeGetDouble(xsid, "pos-z");
../aax_driver.c:      eptr = strchr(nptr, '-');
../aax_driver.c:      eptr = strchr(nptr, '-');
../aax_driver.c:      key -= strtoll(nptr, &eptr, base);
../aax_driver.c:      if (((key^HANDLE_ID) % 29723) == (7*strlen(keystr)-5)) {	/* 177 */
../aax_driver.c:      xmlNodeCopyString(xcid, "product-key", keystr, 27);
../aax_driver.c:   _aaxAudioFrame* smixer = sensor->mixer;
../aax_driver.c:   free(sensor->filter[EQUALIZER_LF].data);
../aax_driver.c:   if (effect) free(effect->history_ptr);
../aax_driver.c:   _intBufErase(&smixer->p3dq, _AAX_DELAYED3D, _aax_aligned_free);
../aax_driver.c:   _aax_aligned_free(smixer->props3d->dprops3d);
../aax_driver.c:   free(smixer->props3d);
../aax_driver.c:   if (smixer->ringbuffer) {
../aax_driver.c:      _aaxRingBufferFree(smixer->ringbuffer);
../aax_driver.c:   _intBufErase(&smixer->frames, _AAX_FRAME, free);
../aax_driver.c:   _intBufErase(&smixer->devices, _AAX_DEVICE, free);
../aax_driver.c:   _intBufErase(&smixer->emitters_2d, _AAX_EMITTER, free);
../aax_driver.c:   _intBufErase(&smixer->emitters_3d, _AAX_EMITTER, free);
../aax_driver.c:   _intBufErase(&smixer->play_ringbuffers, _AAX_RINGBUFFER,
../aax_driver.c:   _intBufErase(&smixer->frame_ringbuffers, _AAX_RINGBUFFER,
../aax_effects.c: * Copyright 2007-2014 by Erik Hofman.
../aax_effects.c: * Copyright 2009-2014 by Adalin B.V.
../aax_effects.c:      _eff_function_tbl *eff = _aaxEffects[type-1];
../aax_effects.c:      rv = eff->create(handle, type);
../aax_effects.c:      _eff_function_tbl *eff = _aaxEffects[effect->type-1];
../aax_effects.c:      rv = eff->destroy(e);
../aax_effects.c:      if ((slot < _MAX_FE_SLOTS) && effect->slot[slot])
../aax_effects.c:         int i, type = effect->type;
../aax_effects.c:               cvtfn_t cvtfn = effect_get_cvtfn(effect->type, ptype, WRITEFN, i);
../aax_effects.c:               effect->slot[slot]->param[i] = _MINMAX(cvtfn(p[i]), min, max);
../aax_effects.c:         if TEST_FOR_TRUE(effect->state) {
../aax_effects.c:            rv = aaxEffectSetState(effect, effect->state);
../aax_effects.c:      } else if ((slot >=_MAX_FE_SLOTS) || !effect->slot[slot]) {
../aax_effects.c:      cvtfn_t cvtfn = effect_get_cvtfn(effect->type, ptype, WRITEFN, param);
../aax_effects.c:      effect->slot[slot]->param[param] = cvtfn(value);
../aax_effects.c:      if TEST_FOR_TRUE(effect->state) {
../aax_effects.c:         aaxEffectSetState(effect, effect->state);
../aax_effects.c:      _eff_function_tbl *eff = _aaxEffects[effect->type-1];
../aax_effects.c:      if (eff->lite || EBF_VALID(effect))
../aax_effects.c:         effect->state = state;
../aax_effects.c:         effect->slot[0]->state = state;
../aax_effects.c:         while ((slot < _MAX_FE_SLOTS) && effect->slot[slot])
../aax_effects.c:            int i, type = effect->type;
../aax_effects.c:               if (!is_nan(effect->slot[slot]->param[i]))
../aax_effects.c:                  cvtfn = effect_get_cvtfn(effect->type,AAX_LINEAR, WRITEFN, i);
../aax_effects.c:                  effect->slot[slot]->param[i] =
../aax_effects.c:                         _MINMAX(cvtfn(effect->slot[slot]->param[i]), min, max);
../aax_effects.c:         rv = eff->state(effect, state);
../aax_effects.c:      rv = effect->state;
../aax_effects.c:      if ((slot < _MAX_FE_SLOTS) && effect->slot[slot])
../aax_effects.c:            cvtfn_t cvtfn = effect_get_cvtfn(effect->type, ptype, READFN, param);
../aax_effects.c:            rv = cvtfn(effect->slot[slot]->param[param]);
../aax_effects.c:      if ((slot < _MAX_FE_SLOTS) && effect->slot[slot])
../aax_effects.c:            cvtfn_t cvtfn = effect_get_cvtfn(effect->type, ptype, READFN, i);
../aax_effects.c:            p[i] = cvtfn(effect->slot[slot]->param[i]);
../aax_effects.c:/* -------------------------------------------------------------------------- */
../aax_effects.c:         cvtfn_t cvtfn = effect_get_cvtfn(effect->type, ptype, READFN, p);
../aax_effects.c:         rv = cvtfn(effect->slot[0]->param[p]);
../aax_effects.c:      _eff_function_tbl *eff = _aaxEffects[type-1];
../aax_effects.c:      rv = eff->handle(info, type, p2d, p3d);
../aax_effects.c:   if (rv && rv->id == EFFECT_ID) {
../aax_emitter.c: * Copyright 2007-2015 by Erik Hofman.
../aax_emitter.c: * Copyright 2009-2015 by Adalin B.V.
../aax_emitter.c:      handle->source = src;
../aax_emitter.c:      src->buffer_pos = UINT_MAX;
../aax_emitter.c:      src->props2d = (_aax2dProps*)ptr2;
../aax_emitter.c:      _aaxSetDefault2dProps(src->props2d);
../aax_emitter.c:      src->props3d = _aax3dPropsCreate();
../aax_emitter.c:      if (src->props3d)
../aax_emitter.c:          _SET_INITIAL(src->props3d);
../aax_emitter.c:         _intBufCreate(&src->buffers, _AAX_EMITTER_BUFFER);
../aax_emitter.c:         if (src->buffers)
../aax_emitter.c:            handle->id = EMITTER_ID;
../aax_emitter.c:            handle->cache_pos = UINT_MAX;
../aax_emitter.c:            handle->mixer_pos = UINT_MAX;
../aax_emitter.c:            handle->looping = AAX_FALSE;
../aax_emitter.c:            _SET_INITIAL(src->props3d);
../aax_emitter.c:      if (!src->buffers)
../aax_emitter.c:         _aax_aligned_free(handle->source->props3d->dprops3d);
../aax_emitter.c:         free(handle->source->props3d);
../aax_emitter.c:      _aaxEmitter *src = handle->source;
../aax_emitter.c:      if (!handle->handle && _IS_PROCESSED(src->props3d))
../aax_emitter.c:         _intBufErase(&src->buffers, _AAX_EMITTER_BUFFER,_aaxFreeEmitterBuffer);
../aax_emitter.c:         if (effect) free(effect->history_ptr);
../aax_emitter.c:         _intBufErase(&src->p3dq, _AAX_DELAYED3D, _aax_aligned_free);
../aax_emitter.c:         _aax_aligned_free(src->props3d->dprops3d);
../aax_emitter.c:         free(src->props3d);
../aax_emitter.c:         handle->id = FADEDBAD;
../aax_emitter.c:         _aaxRingBuffer *rb = buffer->ringbuffer;
../aax_emitter.c:         if (!rb->get_state(rb, RB_IS_VALID)) {
../aax_emitter.c:         } else if (handle->track >= rb->get_parami(rb, RB_NO_TRACKS)) {
../aax_emitter.c:      _aaxRingBuffer *rb = buffer->ringbuffer;
../aax_emitter.c:      const _aaxEmitter *src = handle->source;
../aax_emitter.c:         embuf->ringbuffer = rb->reference(rb);
../aax_emitter.c:         embuf->id = EMBUFFER_ID;
../aax_emitter.c:         embuf->buffer = buffer;
../aax_emitter.c:         buffer->ref_counter++;
../aax_emitter.c:         _intBufAddData(src->buffers, _AAX_EMITTER_BUFFER, embuf);
../aax_emitter.c:         _aaxEmitter *src = handle->source;
../aax_emitter.c:         if (!_IS_PROCESSED(src->props3d) && src->buffer_pos == 0) {
../aax_emitter.c:      _aaxEmitter *src = handle->source;
../aax_emitter.c:      buf = _intBufPop(src->buffers, _AAX_EMITTER_BUFFER);
../aax_emitter.c:            assert(embuf->id == EMBUFFER_ID);
../aax_emitter.c:            free_buffer(embuf->buffer);
../aax_emitter.c:            _aaxRingBufferFree(embuf->ringbuffer);
../aax_emitter.c:            embuf->ringbuffer = NULL;
../aax_emitter.c:            embuf->id = FADEDBAD;
../aax_emitter.c:         if (src->buffer_pos > 0) {
../aax_emitter.c:            src->buffer_pos--;
../aax_emitter.c:         if (_intBufGetNumNoLock(src->buffers, _AAX_EMITTER_BUFFER) == 0) {
../aax_emitter.c:            handle->track = 0; 
../aax_emitter.c:      const _aaxEmitter *src = handle->source;
../aax_emitter.c:      dptr = _intBufGet(src->buffers, _AAX_EMITTER_BUFFER, pos);
../aax_emitter.c:         _buffer_t* buf = embuf->buffer;
../aax_emitter.c:         assert(embuf->id == EMBUFFER_ID);
../aax_emitter.c:         if (copy) buf->ref_counter++;
../aax_emitter.c:         rv = embuf->buffer;
../aax_emitter.c:      const _aaxEmitter *src = handle->source;
../aax_emitter.c:         if (_IS_PROCESSED(src->props3d)) {
../aax_emitter.c:            rv = _intBufGetNumNoLock(src->buffers, _AAX_EMITTER_BUFFER);
../aax_emitter.c:         } else if (src->buffer_pos > 0) {
../aax_emitter.c:            rv = src->buffer_pos;
../aax_emitter.c:         if (_IS_PLAYING(src->props3d)) {
../aax_emitter.c:            rv = _intBufGetNumNoLock(src->buffers, _AAX_EMITTER_BUFFER);
../aax_emitter.c:            rv -= src->buffer_pos;
../aax_emitter.c:         rv = _intBufGetNumNoLock(src->buffers, _AAX_EMITTER_BUFFER);
../aax_emitter.c:      _aaxEmitter *src = handle->source;
../aax_emitter.c:         if (!_IS_PLAYING(src->props3d) || _IS_STOPPED(src->props3d))
../aax_emitter.c:            num = _intBufGetNumNoLock(src->buffers, _AAX_EMITTER_BUFFER);
../aax_emitter.c:               src->buffer_pos = 0;
../aax_emitter.c:               _SET_PLAYING(src->props3d);
../aax_emitter.c:         else if (_IS_PAUSED(src->props3d)) {
../aax_emitter.c:            _TAS_PAUSED(src->props3d, AAX_FALSE);
../aax_emitter.c:         if (handle->mixer_pos != UINT_MAX)	/* emitter is registered */
../aax_emitter.c:            _handle_t *phandle = handle->handle;
../aax_emitter.c:            if (phandle->id == HANDLE_ID)
../aax_emitter.c:               dptr = _intBufGet(phandle->sensors, _AAX_SENSOR, 0);
../aax_emitter.c:                  _aaxAudioFrame *pmixer = sensor->mixer;
../aax_emitter.c:            else if (phandle->id == AUDIOFRAME_ID)
../aax_emitter.c:               _aaxAudioFrame *pmixer = ((_frame_t*)phandle)->submix;
../aax_emitter.c:         if (_IS_PLAYING(src->props3d))
../aax_emitter.c:            if (!_PROP_DISTDELAY_IS_DEFINED(src->props3d))
../aax_emitter.c:               _SET_PROCESSED(src->props3d);
../aax_emitter.c:               src->buffer_pos = UINT_MAX;
../aax_emitter.c:               _SET_STOPPED(src->props3d);
../aax_emitter.c:         if (_IS_PLAYING(src->props3d))
../aax_emitter.c:            _SET_PROCESSED(src->props3d);
../aax_emitter.c:            src->buffer_pos = UINT_MAX;
../aax_emitter.c:         if (_IS_PLAYING(src->props3d)) {
../aax_emitter.c:            _SET_PAUSED(src->props3d);
../aax_emitter.c:         src->buffer_pos = 0;
../aax_emitter.c:         dptr = _intBufGet(src->buffers, _AAX_EMITTER_BUFFER, 0);
../aax_emitter.c:            _aaxRingBuffer *rb = embuf->ringbuffer;
../aax_emitter.c:            rb->set_state(rb, RB_REWINDED);
../aax_emitter.c:            src->buffer_pos = 0;
../aax_emitter.c:            src->curr_pos_sec = 0.0f;
../aax_emitter.c:               env->value = _FILTER_GET(src->props2d, TIMED_GAIN_FILTER, 0);
../aax_emitter.c:               env->stage =  env->pos = 0;
../aax_emitter.c:               env->value = _EFFECT_GET(src->props2d, TIMED_PITCH_EFFECT, 0);
../aax_emitter.c:               env->stage =  env->pos = 0;
../aax_emitter.c:         _aaxEmitter *src = handle->source;
../aax_emitter.c:         int type = filter->pos;
../aax_emitter.c:         switch (filter->type)
../aax_emitter.c:            _PROP_DISTDELAY_SET_DEFINED(src->props3d);
../aax_emitter.c:            _aax2dProps *p2d = src->props2d;
../aax_emitter.c:            _aax3dProps *p3d = src->props3d;
../aax_emitter.c:            _aax3dProps *p3d = src->props3d;
../aax_emitter.c:         _aaxEmitter *src = handle->source;
../aax_emitter.c:         _handle_t *cfg = get_driver_handle(handle->handle);
../aax_emitter.c:         _aaxMixerInfo* info = (cfg) ? cfg->info : _info;
../aax_emitter.c:         rv = new_filter_handle(info, type, src->props2d, src->props3d);
../aax_emitter.c:         _aaxEmitter *src = handle->source;
../aax_emitter.c:         int type = effect->pos;
../aax_emitter.c:         switch (effect->type)
../aax_emitter.c:            _PROP_PITCH_SET_CHANGED(src->props3d);
../aax_emitter.c:            _aax2dProps *p2d = src->props2d;
../aax_emitter.c:            _aax2dProps *p2d = src->props2d;
../aax_emitter.c:            if (_intBufGetNumNoLock(src->buffers, _AAX_EMITTER_BUFFER) > 1)
../aax_emitter.c:               if (data && !data->history_ptr)
../aax_emitter.c:                  unsigned int tracks = effect->info->no_tracks;
../aax_emitter.c:                  float frequency = effect->info->frequency;
../aax_emitter.c:                  _aaxRingBufferCreateHistoryBuffer(&data->history_ptr,
../aax_emitter.c:                                                    data->delay_history,
../aax_emitter.c:            _aax2dProps *p2d = src->props2d;
../aax_emitter.c:               _PROP_DYNAMIC_PITCH_SET_DEFINED(src->props3d);
../aax_emitter.c:               if ((lfo_val > 1.0f) && (src->update_rate < 4*lfo_val)) {
../aax_emitter.c:                  src->update_rate = 1;
../aax_emitter.c:               _PROP_DYNAMIC_PITCH_CLEAR_DEFINED(src->props3d);
../aax_emitter.c:               src->update_rate = 0;
../aax_emitter.c:            _aax3dProps *p3d = src->props3d;
../aax_emitter.c:         _aaxEmitter *src = handle->source;
../aax_emitter.c:         rv = new_effect_handle(src->info, type, src->props2d, src->props3d);
../aax_emitter.c:      _aaxEmitter *src = handle->source;
../aax_emitter.c:         _TAS_POSITIONAL(src->props3d, m);
../aax_emitter.c:            _TAS_RELATIVE(src->props3d, m);
../aax_emitter.c:               src->props3d->dprops3d->matrix[LOCATION][3] = 0.0f;
../aax_emitter.c:               src->props3d->dprops3d->velocity[VELOCITY][3] = 0.0f;
../aax_emitter.c:               src->props3d->dprops3d->matrix[LOCATION][3] = 1.0f;
../aax_emitter.c:               src->props3d->dprops3d->velocity[VELOCITY][3] = 1.0f;
../aax_emitter.c:         _intBufferData *dptr =_intBufGet(src->buffers, _AAX_EMITTER_BUFFER, 0);
../aax_emitter.c:            _aaxRingBuffer *rb = embuf->ringbuffer;
../aax_emitter.c:            rb->set_parami(rb, RB_LOOPING, mode);
../aax_emitter.c:         handle->looping = mode;
../aax_emitter.c:         _intBufferData *dptr =_intBufGet(src->buffers, _AAX_EMITTER_BUFFER, 0);
../aax_emitter.c:            _aaxRingBuffer *rb = embuf->buffer->ringbuffer;
../aax_emitter.c:            if (mode < rb->get_parami(rb, RB_NO_TRACKS))
../aax_emitter.c:               handle->track = mode;
../aax_emitter.c:      _aaxEmitter *src = handle->source;
../aax_emitter.c:      mtx4Copy(src->props3d->dprops3d->matrix, mtx);
../aax_emitter.c:      if (_IS_RELATIVE(src->props3d)) {
../aax_emitter.c:         src->props3d->dprops3d->matrix[LOCATION][3] = 0.0f;
../aax_emitter.c:         src->props3d->dprops3d->matrix[LOCATION][3] = 1.0f;
../aax_emitter.c:      _PROP_MTX_SET_CHANGED(src->props3d);
../aax_emitter.c:      dp3d = handle->source->props3d->dprops3d;
../aax_emitter.c:      vec3Copy(dp3d->velocity[VELOCITY], velocity);
../aax_emitter.c:      _PROP_SPEED_SET_CHANGED(handle->source->props3d);
../aax_emitter.c:      _aaxEmitter *src = handle->source;
../aax_emitter.c:      mtx4Copy(mtx, src->props3d->dprops3d->matrix);
../aax_emitter.c:      _aaxEmitter *src = handle->source;
../aax_emitter.c:      _intBufGetNum(src->buffers, _AAX_EMITTER_BUFFER);
../aax_emitter.c:      dptr = _intBufGet(src->buffers, _AAX_EMITTER_BUFFER, 0);
../aax_emitter.c:         _aaxRingBuffer *rb = embuf->ringbuffer;
../aax_emitter.c:         float duration, fpos = (float)offs*1e-6f;
../aax_emitter.c:            offs /= rb->get_parami(rb, RB_BYTES_SAMPLE);
../aax_emitter.c:            samples = rb->get_parami(rb, RB_NO_SAMPLES);
../aax_emitter.c:               offs -= samples;
../aax_emitter.c:               dptr = _intBufGet(src->buffers, _AAX_EMITTER_BUFFER, pos);
../aax_emitter.c:               rb = embuf->ringbuffer;
../aax_emitter.c:               samples = rb->get_parami(rb, RB_NO_SAMPLES);
../aax_emitter.c:               handle->mixer_pos = pos;
../aax_emitter.c:               rb->set_parami(rb, RB_OFFSET_SAMPLES, offs);
../aax_emitter.c:            duration = rb->get_paramf(rb, RB_DURATION_SEC);
../aax_emitter.c:               fpos -= duration;
../aax_emitter.c:               dptr = _intBufGet(src->buffers, _AAX_EMITTER_BUFFER, pos);
../aax_emitter.c:               rb = embuf->ringbuffer;
../aax_emitter.c:               duration = rb->get_paramf(rb, RB_DURATION_SEC);
../aax_emitter.c:               handle->mixer_pos = pos;
../aax_emitter.c:               rb->set_paramf(rb, RB_OFFSET_SEC, fpos);
../aax_emitter.c:      _intBufReleaseNum(src->buffers, _AAX_EMITTER_BUFFER);
../aax_emitter.c:      _aaxEmitter *src = handle->source;
../aax_emitter.c:      _intBufGetNum(src->buffers, _AAX_EMITTER_BUFFER);
../aax_emitter.c:      dptr = _intBufGet(src->buffers, _AAX_EMITTER_BUFFER, 0);
../aax_emitter.c:         _aaxRingBuffer *rb = embuf->ringbuffer;
../aax_emitter.c:         duration = rb->get_paramf(rb, RB_DURATION_SEC);
../aax_emitter.c:            offs -= duration;
../aax_emitter.c:            dptr = _intBufGet(src->buffers, _AAX_EMITTER_BUFFER, pos);
../aax_emitter.c:            rb = embuf->ringbuffer;
../aax_emitter.c:            duration = rb->get_paramf(rb, RB_DURATION_SEC);
../aax_emitter.c:            handle->mixer_pos = pos;
../aax_emitter.c:            rb->set_paramf(rb, RB_OFFSET_SEC, offs);
../aax_emitter.c:      _intBufReleaseNum(src->buffers, _AAX_EMITTER_BUFFER);
../aax_emitter.c:      const _aaxEmitter *src = handle->source;
../aax_emitter.c:         if (_IS_POSITIONAL(src->props3d))
../aax_emitter.c:            if (_IS_RELATIVE(src->props3d)) {
../aax_emitter.c:         _intBufferData *dptr =_intBufGet(src->buffers, _AAX_EMITTER_BUFFER, 0);
../aax_emitter.c:            _aaxRingBuffer *rb = embuf->ringbuffer;
../aax_emitter.c:            rv = rb->get_parami(rb, RB_LOOPING);
../aax_emitter.c:         rv = handle->track;
../aax_emitter.c:      dp3d = handle->source->props3d->dprops3d;
../aax_emitter.c:      vec3Copy(velocity, dp3d->velocity[VELOCITY]);
../aax_emitter.c:      _handle_t *thread = get_valid_handle(handle->handle);
../aax_emitter.c:         const _aaxEmitter *src = handle->source;
../aax_emitter.c:         if (_IS_PROCESSED(src->props3d)) ret = AAX_PROCESSED;
../aax_emitter.c:         else if (_IS_STOPPED(src->props3d)) ret = AAX_STOPPED;
../aax_emitter.c:         else if (_IS_PAUSED(src->props3d)) ret = AAX_SUSPENDED;
../aax_emitter.c:         else if (_IS_PLAYING(src->props3d)) ret = AAX_PLAYING;
../aax_emitter.c:      const _aaxEmitter *src = handle->source;
../aax_emitter.c:      dptr = _intBufGet(src->buffers, _AAX_EMITTER_BUFFER, 0);
../aax_emitter.c:            _intBufGetNum(src->buffers, _AAX_EMITTER_BUFFER);
../aax_emitter.c:            _aaxRingBuffer *rb = embuf->ringbuffer;
../aax_emitter.c:            for (i=0; i<handle->mixer_pos; i++)
../aax_emitter.c:               rv += rb->get_parami(rb, RB_NO_SAMPLES);
../aax_emitter.c:               dptr = _intBufGet(src->buffers, _AAX_EMITTER_BUFFER, i);
../aax_emitter.c:            _intBufReleaseNum(src->buffers, _AAX_EMITTER_BUFFER);
../aax_emitter.c:            rv += rb->get_parami(rb, RB_OFFSET_SAMPLES);
../aax_emitter.c:               rv *= rb->get_parami(rb, RB_BYTES_SAMPLE);
../aax_emitter.c:            rv = (unsigned long)(src->curr_pos_sec * 1e6f);
../aax_emitter.c:      const _aaxEmitter *src = handle->source;
../aax_emitter.c:      rv = src->curr_pos_sec;
../aax_emitter.c:/* -------------------------------------------------------------------------- */
../aax_emitter.c:   if (emitter && emitter->id == EMITTER_ID && !emitter->handle) {
../aax_emitter.c:   if (emitter && emitter->id == EMITTER_ID)
../aax_emitter.c:      _handle_t *handle = emitter->handle;
../aax_emitter.c:      if (handle && handle->id == HANDLE_ID)
../aax_emitter.c:         _intBufferData *dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_emitter.c:            _aaxAudioFrame* mixer = sensor->mixer;
../aax_emitter.c:            if (!_IS_POSITIONAL(emitter->source->props3d)) {
../aax_emitter.c:               he = mixer->emitters_2d;
../aax_emitter.c:               he = mixer->emitters_3d;
../aax_emitter.c:            dptr_src = _intBufGet(he, _AAX_EMITTER, emitter->mixer_pos);
../aax_emitter.c:      else if (handle && handle->id == AUDIOFRAME_ID)
../aax_emitter.c:         _frame_t *handle = (_frame_t*)emitter->handle;
../aax_emitter.c:         if (!_IS_POSITIONAL(emitter->source->props3d)) {
../aax_emitter.c:            he = handle->submix->emitters_2d;
../aax_emitter.c:            he = handle->submix->emitters_3d;
../aax_emitter.c:         dptr_src = _intBufGet(he, _AAX_EMITTER, emitter->mixer_pos);
../aax_emitter.c:   if (emitter && emitter->id == EMITTER_ID)
../aax_emitter.c:      _handle_t *handle = emitter->handle;
../aax_emitter.c:      if (handle && handle->id == HANDLE_ID)
../aax_emitter.c:          _intBufferData *dptr =_intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_emitter.c:            _aaxAudioFrame* mixer = sensor->mixer;
../aax_emitter.c:            if (!_IS_POSITIONAL(emitter->source->props3d)) {
../aax_emitter.c:               he = mixer->emitters_2d;
../aax_emitter.c:               he = mixer->emitters_3d;
../aax_emitter.c:            _intBufRelease(he, _AAX_EMITTER, emitter->mixer_pos);
../aax_emitter.c:      else if (handle && handle->id == AUDIOFRAME_ID)
../aax_emitter.c:         _frame_t *handle = (_frame_t*)emitter->handle;
../aax_emitter.c:         if (!_IS_POSITIONAL(emitter->source->props3d)) {
../aax_emitter.c:            he = handle->submix->emitters_2d;
../aax_emitter.c:            he = handle->submix->emitters_3d;
../aax_emitter.c:         _intBufRelease(he, _AAX_EMITTER, emitter->mixer_pos);
../aax_emitter.c:   dist_delaying = _FILTER_GET_STATE(src->props3d, DISTANCE_FILTER);
../aax_emitter.c:   dist_delaying |= _FILTER_GET_STATE(mixer->props3d, DISTANCE_FILTER);
../aax_emitter.c:      _aax3dProps *fp3d = mixer->props3d;
../aax_emitter.c:      _aaxDelayed3dProps *fdp3d_m = fp3d->m_dprops3d;
../aax_emitter.c:      _aax3dProps *ep3d = src->props3d;
../aax_emitter.c:      _aaxDelayed3dProps *edp3d_m = ep3d->m_dprops3d;
../aax_emitter.c:      _aaxDelayed3dProps *edp3d = ep3d->dprops3d;
../aax_emitter.c:      _aax2dProps *ep2d = src->props2d;
../aax_emitter.c:      mtx4Mul(edp3d_m->matrix, fdp3d_m->matrix, edp3d->matrix);
../aax_emitter.c:      dist = vec3Magnitude(edp3d_m->matrix[LOCATION]);
../aax_emitter.c:      ep2d->dist_delay_sec = dist / vs;
../aax_emitter.c: PRINT_MATRICES(fdp3d_m->matrix, edp3d->matrix);
../aax_emitter.c: PRINT_MATRIX(edp3d_m->matrix);
../aax_emitter.c: printf("delay: %f, dist: %f, vs: %f\n", ep2d->dist_delay_sec, dist, vs);
../aax_emitter.c:      src->props3d->buf3dq_step = 1.0f;
../aax_emitter.c:      if (!src->p3dq) {
../aax_emitter.c:         _intBufCreate(&src->p3dq, _AAX_DELAYED3D);
../aax_emitter.c:         _intBufClear(src->p3dq, _AAX_DELAYED3D, _aax_aligned_free);
../aax_emitter.c:   free_buffer(embuf->buffer);
../aax_emitter.c:   _aaxRingBufferFree(embuf->ringbuffer);
../aax_emitter.c:   embuf->ringbuffer = NULL;
../aax_emitter.c:   embuf->id = FADEDBAD;
../aax_eventmgr.c: * Copyright 2013-2014 by Erik Hofman.
../aax_eventmgr.c: * Copyright 2013-2014 by Adalin B.V.
../aax_eventmgr.c:   if (handle && !handle->eventmgr)
../aax_eventmgr.c:      handle->eventmgr = calloc(1, sizeof(_aaxEventMgr));
../aax_eventmgr.c:      if (handle->eventmgr)
../aax_eventmgr.c:         _aaxEventMgr *eventmgr = handle->eventmgr;
../aax_eventmgr.c:         _intBufCreate(&eventmgr->frames, _AAX_FRAME_CACHE);
../aax_eventmgr.c:         _intBufCreate(&eventmgr->buffers, _AAX_BUFFER_CACHE);
../aax_eventmgr.c:         _intBufCreate(&eventmgr->emitters, _AAX_EMITTER_CACHE);
../aax_eventmgr.c:   if (handle && handle->eventmgr)
../aax_eventmgr.c:      _aaxEventMgr *eventmgr = handle->eventmgr;
../aax_eventmgr.c:      _intBufErase(&eventmgr->emitters,_AAX_EMITTER_CACHE,_aaxFreeEmitterCache);
../aax_eventmgr.c:      _intBufErase(&eventmgr->buffers, _AAX_BUFFER_CACHE, _aaxFreeBufferCache);
../aax_eventmgr.c:      _intBufErase(&eventmgr->frames, _AAX_FRAME_CACHE, _aaxFreeFrameCache);
../aax_eventmgr.c:      free(handle->eventmgr);
../aax_eventmgr.c:      handle->eventmgr = NULL;
../aax_eventmgr.c:   if (handle && handle->eventmgr)
../aax_eventmgr.c:      _aaxEventMgr *eventmgr = handle->eventmgr;
../aax_eventmgr.c:   if (handle && handle->eventmgr)
../aax_eventmgr.c:            _aaxEventMgr *eventmgr = handle->eventmgr;
../aax_eventmgr.c:            fr->frame = rv;
../aax_eventmgr.c:            fr->frame->cache_pos = _intBufAddData(eventmgr->frames,
../aax_eventmgr.c:      if (config && config->eventmgr)
../aax_eventmgr.c:         _aaxEventMgr *eventmgr = config->eventmgr;
../aax_eventmgr.c:                  em->frame = frame;
../aax_eventmgr.c:                  em->emitter = rv;
../aax_eventmgr.c:                  em->emitter->cache_pos = _intBufAddData(eventmgr->emitters,
../aax_eventmgr.c:      if (config && config->eventmgr)
../aax_eventmgr.c:   if (handle && handle->eventmgr)
../aax_eventmgr.c:            if (em && em->cache_pos != UINT_MAX)
../aax_eventmgr.c:               _aaxEventMgr *eventmgr = handle->eventmgr;
../aax_eventmgr.c:               unsigned int pos = em->cache_pos;
../aax_eventmgr.c:               dptr = _intBufGet(eventmgr->emitters, _AAX_EMITTER_CACHE, pos);
../aax_eventmgr.c:                     ev->id = EVENT_ID;
../aax_eventmgr.c:                     ev->emitter_pos = pos;
../aax_eventmgr.c:                     ev->data = emitter;
../aax_eventmgr.c:                     ev->event = event_type;
../aax_eventmgr.c:                     ev->callback = callback;
../aax_eventmgr.c:                     ev->user_data = user_data;
../aax_eventmgr.c:                     _intBufAddData(em_cache->events, _AAX_EVENT_QUEUE, ev);
../aax_eventmgr.c:   if (handle && handle->eventmgr && eventmgr)
../aax_eventmgr.c:   if (handle && handle->eventmgr)
../aax_eventmgr.c:   if (handle && handle->eventmgr)
../aax_eventmgr.c:/* -------------------------------------------------------------------------- */
../aax_eventmgr.c:   eventmgr->thread.ptr = _aaxThreadCreate();
../aax_eventmgr.c:   assert(eventmgr->thread.ptr != 0);
../aax_eventmgr.c:   _aaxSignalInit(&eventmgr->thread.signal);
../aax_eventmgr.c:   assert(eventmgr->thread.signal.condition != 0);
../aax_eventmgr.c:   assert(eventmgr->thread.signal.mutex != 0);
../aax_eventmgr.c:   res = _aaxThreadStart(eventmgr->thread.ptr, _aaxEventThread, eventmgr, 20);
../aax_eventmgr.c:      eventmgr->thread.started = AAX_TRUE;
../aax_eventmgr.c:   if TEST_FOR_TRUE(eventmgr->thread.started)
../aax_eventmgr.c:      eventmgr->thread.started = AAX_FALSE;
../aax_eventmgr.c:      _aaxSignalTrigger(&eventmgr->thread.signal);
../aax_eventmgr.c:      _aaxThreadJoin(eventmgr->thread.ptr);
../aax_eventmgr.c:      _aaxSignalFree(&eventmgr->thread.signal);
../aax_eventmgr.c:      _aaxThreadDestroy(eventmgr->thread.ptr);
../aax_eventmgr.c:   handle = get_driver_handle(fr->frame);
../aax_eventmgr.c:   aaxAudioFrameSetState(fr->frame, AAX_PROCESSED);
../aax_eventmgr.c:   aaxMixerDeregisterAudioFrame(handle, fr->frame);
../aax_eventmgr.c:   aaxAudioFrameDestroy(fr->frame);
../aax_eventmgr.c:// _intBufErase(&fr->events, _AAX_EVENT_QUEUE, free);
../aax_eventmgr.c:   aaxBufferDestroy(buf->buffer);
../aax_eventmgr.c:   free(buf->fname);
../aax_eventmgr.c:   aaxEmitterSetState(em->emitter, AAX_PROCESSED);
../aax_eventmgr.c:   aaxAudioFrameDeregisterEmitter(em->frame, em->emitter);
../aax_eventmgr.c:   aaxEmitterDestroy(em->emitter);
../aax_eventmgr.c:   _intBufErase(&em->events, _AAX_EVENT_QUEUE, free);
../aax_filters.c: * Copyright 2007-2014 by Erik Hofman.
../aax_filters.c: * Copyright 2009-2014 by Adalin B.V.
../aax_filters.c:#define EPS		1e-5
../aax_filters.c:      _flt_function_tbl *flt = _aaxFilters[type-1];
../aax_filters.c:      rv = flt->create(handle, type);
../aax_filters.c:      _flt_function_tbl *flt = _aaxFilters[filter->type-1];
../aax_filters.c:      rv = flt->destroy(filter);
../aax_filters.c:      if ((slot < _MAX_FE_SLOTS) && filter->slot[slot])
../aax_filters.c:         int i, type = filter->type;
../aax_filters.c:               cvtfn_t cvtfn = filter_get_cvtfn(filter->type, ptype, WRITEFN, i);
../aax_filters.c:               filter->slot[slot]->param[i] = _MINMAX(cvtfn(p[i]), min, max);
../aax_filters.c:         if TEST_FOR_TRUE(filter->state) {
../aax_filters.c:            rv = aaxFilterSetState(filter, filter->state);
../aax_filters.c:      } else if ((slot >=_MAX_FE_SLOTS) || !filter->slot[slot]) {
../aax_filters.c:      cvtfn_t cvtfn = filter_get_cvtfn(filter->type, ptype, WRITEFN, param);
../aax_filters.c:      filter->slot[slot]->param[param] = cvtfn(value);
../aax_filters.c:      if TEST_FOR_TRUE(filter->state) {
../aax_filters.c:         aaxFilterSetState(filter, filter->state);
../aax_filters.c:      _flt_function_tbl *flt = _aaxFilters[filter->type-1];
../aax_filters.c:      if (flt->lite || EBF_VALID(filter))
../aax_filters.c:         filter->state = state;
../aax_filters.c:         filter->slot[0]->state = state;
../aax_filters.c:         while ((slot < _MAX_FE_SLOTS) && filter->slot[slot])
../aax_filters.c:            int i, type = filter->type;
../aax_filters.c:               if (!is_nan(filter->slot[slot]->param[i]))
../aax_filters.c:                  cvtfn = filter_get_cvtfn(filter->type,AAX_LINEAR, WRITEFN, i);
../aax_filters.c:                  filter->slot[slot]->param[i] =
../aax_filters.c:                         _MINMAX(cvtfn(filter->slot[slot]->param[i]), min, max);
../aax_filters.c:         rv = flt->state(filter, state);
../aax_filters.c:      rv = filter->state;
../aax_filters.c:      if ((slot < _MAX_FE_SLOTS) && filter->slot[slot])
../aax_filters.c:            cvtfn_t cvtfn = filter_get_cvtfn(filter->type, ptype, READFN, param);
../aax_filters.c:            rv = cvtfn(filter->slot[slot]->param[param]);
../aax_filters.c:      if ((slot < _MAX_FE_SLOTS) && filter->slot[slot])
../aax_filters.c:            cvtfn_t cvtfn = filter_get_cvtfn(filter->type, ptype, READFN, i);
../aax_filters.c:            p[i] = cvtfn(filter->slot[slot]->param[i]);
../aax_filters.c:/* -------------------------------------------------------------------------- */
../aax_filters.c:         cvtfn_t cvtfn = filter_get_cvtfn(filter->type, ptype, READFN, p);
../aax_filters.c:         rv = cvtfn(filter->slot[0]->param[p]);
../aax_filters.c:      _flt_function_tbl *flt = _aaxFilters[type-1];
../aax_filters.c:      rv = flt->handle(info, type, p2d, p3d);
../aax_filters.c:   if (rv && rv->id == FILTER_ID) {
../aax_instrument.c: * Copyright 2012-2014 by Erik Hofman.
../aax_instrument.c: * Copyright 2012-2014 by Adalin B.V.
../aax_instrument.c:        inst->id = INSTRUMENT_ID;
../aax_instrument.c:        inst->handle = config;
../aax_instrument.c:        inst->frequency_hz = 44100;
../aax_instrument.c:        inst->format = AAX_PCM16S;
../aax_instrument.c:        inst->sound_min = 3;
../aax_instrument.c:        inst->sound_max = 87;
../aax_instrument.c:        inst->sound_step = 12;		/* one octave */
../aax_instrument.c:        inst->frame = aaxAudioFrameCreate(config);
../aax_instrument.c:        aaxAudioFrameSetState(inst->frame, AAX_PLAYING);
../aax_instrument.c:        aaxMixerRegisterAudioFrame(config, inst->frame);
../aax_instrument.c:        aaxAudioFrameSetState(inst->frame, AAX_STOPPED);
../aax_instrument.c:        aaxMixerDeregisterAudioFrame(inst->handle, inst->frame);
../aax_instrument.c:        aaxAudioFrameDestroy(inst->frame);
../aax_instrument.c:        _intBufErase(&inst->note, _AAX_NOTE, free);
../aax_instrument.c:        inst->id = 0xdeadbeaf;
../aax_instrument.c:            inst->frequency_hz = setup;
../aax_instrument.c:            inst->format = setup;
../aax_instrument.c:            rv = inst->frequency_hz;
../aax_instrument.c:            rv = inst->format;
../aax_instrument.c:            inst->sustain = value;
../aax_instrument.c:            inst->soften = value;
../aax_instrument.c:            rv = inst->sustain;
../aax_instrument.c:            rv = inst->soften;
../aax_instrument.c:                unsigned int pos = note_no % inst->polyphony;
../aax_instrument.c:                    note->pitchbend = _MINMAX(value, 0.0f, 1.0f);
../aax_instrument.c:                    note->velocity = _MINMAX(value, 0.0f, 1.0f);
../aax_instrument.c:                    note->aftertouch = _MINMAX(value, 0.0f, 1.0f);
../aax_instrument.c:                    note->displacement = _MINMAX(value, 0.0f, 1.0f);
../aax_instrument.c://                  note->sustain = _MINMAX(value, 0.0f, 1.0f);
../aax_instrument.c://                  note->soften = _MINMAX(value, 0.0f, 1.0f);
../aax_instrument.c:            unsigned int pos = note_no % inst->polyphony;
../aax_instrument.c:                rv = note->pitchbend;
../aax_instrument.c:                rv = note->velocity;
../aax_instrument.c:                rv = note->aftertouch;
../aax_instrument.c:                rv = note->displacement;
../aax_instrument.c://              rv = note->sustain;
../aax_instrument.c:                rv = inst->sustain;
../aax_instrument.c://              rv = note->soften;
../aax_instrument.c:                rv = inst->soften;
../aax_instrument.c:/* ------------------------------------------------------------------------- */
../aax_instrument.c:   if (controller && controller->id == INSTRUMENT_ID) {
../aax_instrument.c:   if (controller && controller->id == INSTRUMENT_ID && controller->handle) {
../aax_instrument.c:    float npow = (n-69.0f)/12.0f;	/* A4 = note 69 for midi layout */
../aax_instrument.c://  inst->sound_min = xmlNodeGetInt(xid, "note-min");
../aax_instrument.c://  inst->sound_max = xmlNodeGetInt(xid, "note-max");
../aax_instrument.c://  if (inst->sound_max <= inst->sound_min) inst->sound_max = 128;
../aax_instrument.c://  inst->sound_step = _MINMAX(xmlNodeGetInt(xid, "note-step"), 1, 128);
../aax_instrument.c:    inst->polyphony = xmlNodeGetInt(xid, "polyphony");	/* no emitters */
../aax_instrument.c:    num = (inst->sound_max-inst->sound_min);
../aax_instrument.c:    inst->sound = malloc(num*(sizeof(_timbre_t*)+sizeof(_timbre_t)));
../aax_instrument.c:    ptr = (char*)(inst->sound + num);
../aax_instrument.c:        inst->sound[i] = (_timbre_t*)ptr;
../aax_instrument.c:            node = xmlNodeGet(xwid, "processing-type");
../aax_instrument.c:            node = xmlNodeGet(xwid, "waveform-type");
../aax_instrument.c:            } else if (!xmlCompareString(node, "white-noise")) {
../aax_instrument.c:            } else if (!xmlCompareString(node, "pink-noise")) {
../aax_instrument.c:            } else if (!xmlCompareString(node, "brownian-noise")) {
../aax_instrument.c:            f = (float)xmlNodeGetDouble(xwid, "gain-ratio");
../aax_instrument.c:    for (j=inst->sound_min; j<inst->sound_max; j += inst->sound_step)
../aax_instrument.c:          * using (j+inst->sound_step-1) makes the last note of the lot
../aax_instrument.c:        freq = _note_to_frequency((float)(j+inst->sound_step-1));
../aax_instrument.c:        buf = aaxBufferCreate(inst->handle, (unsigned int)(0.25f*freq), 1, format);
../aax_instrument.c:        k = j - inst->sound_min;
../aax_instrument.c:        for (n=0; n<inst->sound_step; n++)
../aax_instrument.c:           inst->sound[k+n]->pitch = f/freq;
../aax_instrument.c:           inst->sound[k+n]->buffer = buf;
../aax_instrument.c:    aaxConfig config = inst->handle;
../aax_instrument.c:    num = inst->polyphony;
../aax_instrument.c:    inst->note = malloc(num*(sizeof(_note_t*)+sizeof(_note_t)));
../aax_instrument.c:        inst->note[i] = (_note_t*)ptr;
../aax_instrument.c:        inst->note[i]->emitter = aaxEmitterCreate();
../aax_instrument.c:                inst->filter[type] = filter;
../aax_instrument.c:    aaxConfig config = inst->handle;
../aax_instrument.c:                inst->effect[type] = effect;
../aax_matrix.c: * Copyright 2007-2014 by Erik Hofman.
../aax_matrix.c: * Copyright 2009-2014 by Adalin B.V.
../aax_matrix.c:            if (at[2] < 0.0f) up[2] = -1.0f;
../aax_matrix.c:         i--;
../aax_matrix.c:            j--;
../aax_midi.c:/* -------------------------------------------------------------------------- */
../aax_midi.c:   { 0x00000000,     8.176f, "C-2",  "C3"  },
../aax_midi.c:   { 0x00010000,     8.662f, "C#-2", "C#3" },
../aax_midi.c:   { 0x00020000,     9.177f, "D-2",  "D3"  },
../aax_midi.c:   { 0x00030000,     9.723f, "D#-2", "D#3" },
../aax_midi.c:   { 0x00040000,    10.301f, "E-2",  "E3"  },
../aax_midi.c:   { 0x00050000,    10.913f, "F-2",  "F3"  },
../aax_midi.c:   { 0x00060000,    11.562f, "F#-2", "F#3" },
../aax_midi.c:   { 0x00070000,    12.250f, "G-2",  "G3"  },
../aax_midi.c:   { 0x00080000,    12.978f, "G#-2", "G#3" },
../aax_midi.c:   { 0x00090000,    13.750f, "A-2",  "A3"  },
../aax_midi.c:   { 0x000a0000,    14.568f, "A#-2", "A#3" },
../aax_midi.c:   { 0x000b0000,    15.434f, "B-2",  "B3"  },
../aax_midi.c:   { 0x000c0000,    16.352f, "C-1",  "C2"  },
../aax_midi.c:   { 0x000d0000,    17.324f, "C#-1", "C#2" },
../aax_midi.c:   { 0x000e0000,    18.354f, "D-1",  "D2"  },
../aax_midi.c:   { 0x000f0000,    19.445f, "D#-1", "D#2" },
../aax_midi.c:   { 0x00100000,    20.602f, "E-1",  "E2"  },
../aax_midi.c:   { 0x00110000,    21.827f, "F-1",  "F2"  },
../aax_midi.c:   { 0x00120000,    23.125f, "F#-1", "F#2" },
../aax_midi.c:   { 0x00130000,    24.500f, "G-1",  "G2"  },
../aax_midi.c:   { 0x00140000,    25.957f, "G#-1", "G#2" },
../aax_midi.c:   { 0x00150000,    27.500f, "A-1",  "A2"  },
../aax_midi.c:   { 0x00160000,    29.135f, "A#-1", "A#2" },
../aax_midi.c:   { 0x00170000,    30.868f, "B-1",  "B2"  },
../aax_midi.c:   "Honky-Tonk Piano",
../aax_midi.c:   "FX 8 (Sci-Fi)",
../aax_midi.c:   "Closed Hi-Hat",
../aax_midi.c:   "Pedal Hi-Hat",
../aax_midi.c:   "Open Hi-Hat",
../aax_mixer.c: * Copyright 2007-2014 by Erik Hofman.
../aax_mixer.c: * Copyright 2009-2014 by Adalin B.V.
../aax_mixer.c:      if (handle && !handle->handle)
../aax_mixer.c:         _aaxMixerInfo* info = handle->info;
../aax_mixer.c:            rv = (setup <= info->max_emitters) ? AAX_TRUE : AAX_FALSE;
../aax_mixer.c:               float iv = info->refresh_rate;
../aax_mixer.c:               info->frequency = (float)setup;
../aax_mixer.c:               info->refresh_rate = iv;
../aax_mixer.c:               info->period_rate = iv;
../aax_mixer.c:                         && (handle->valid & HANDLE_ID))
../aax_mixer.c:               float update_hz = info->refresh_rate/info->update_rate;
../aax_mixer.c:               float fq = info->frequency;
../aax_mixer.c:               info->refresh_rate = iv;
../aax_mixer.c:               info->period_rate = iv;
../aax_mixer.c:               info->update_rate = (uint8_t)rintf(iv/update_hz);
../aax_mixer.c:                         && (handle->valid & HANDLE_ID))
../aax_mixer.c:               info->update_rate = (uint8_t)rintf(info->refresh_rate/setup);
../aax_mixer.c:               float fq = info->frequency;
../aax_mixer.c:               info->refresh_rate = iv;
../aax_mixer.c:               info->period_rate = iv;
../aax_mixer.c:                info->bitrate = setup;
../aax_mixer.c:               info->format = setup;
../aax_mixer.c:               info->no_tracks = setup;
../aax_mixer.c:               info->track = setup;
../aax_mixer.c:                  info->no_tracks = 1;
../aax_mixer.c:         _aaxMixerInfo* info = handle->info;
../aax_mixer.c:               info->track = setup;
../aax_mixer.c:                  info->no_tracks = 1;
../aax_mixer.c:                info->bitrate = setup;
../aax_mixer.c:            _aaxMixerInfo* info = handle->info;
../aax_mixer.c:               rv = info->max_emitters;
../aax_mixer.c:               rv = info->max_emitters/2;
../aax_mixer.c:               rv = VALID_HANDLE(handle) ? info->max_emitters : 0;
../aax_mixer.c:               rv = (unsigned int)info->frequency;
../aax_mixer.c:               rv = (unsigned int)info->period_rate;
../aax_mixer.c:                rv=(unsigned int)(info->refresh_rate/handle->info->update_rate);
../aax_mixer.c:               rv = (int)(handle->elapsed*1000000.0f);
../aax_mixer.c:               rv = info->bitrate;
../aax_mixer.c:               _aaxRingBuffer *rb = handle->ringbuffer;
../aax_mixer.c:               int bps = rb->get_parami(rb, RB_BYTES_SAMPLE);
../aax_mixer.c:               rv = (unsigned int)(info->frequency*bps/info->period_rate);
../aax_mixer.c:               rv = info->no_tracks;
../aax_mixer.c:               rv = info->format;
../aax_mixer.c:            if (handle->backend.driver)
../aax_mixer.c:               const _aaxDriverBackend *be = handle->backend.ptr;
../aax_mixer.c:                  f = be->param(handle->backend.handle, DRIVER_LATENCY);
../aax_mixer.c:                  rv= be->param(handle->backend.handle, DRIVER_SAMPLE_DELAY);
../aax_mixer.c:                  f = be->param(handle->backend.handle, DRIVER_SHARED_MODE);
../aax_mixer.c:                  f = be->param(handle->backend.handle, DRIVER_TIMER_MODE);
../aax_mixer.c:                  f = be->param(handle->backend.handle, DRIVER_BATCHED_MODE);
../aax_mixer.c:                  f = be->param(handle->backend.handle,DRIVER_SEEKABLE_SUPPORT);
../aax_mixer.c:                  f = be->param(handle->backend.handle, DRIVER_MIN_TRACKS);
../aax_mixer.c:                  f = be->param(handle->backend.handle, DRIVER_MAX_TRACKS);
../aax_mixer.c:                  f = be->param(handle->backend.handle, DRIVER_MIN_PERIODS);
../aax_mixer.c:                  f = be->param(handle->backend.handle, DRIVER_MAX_PERIODS);
../aax_mixer.c:                  f = be->param(handle->backend.handle,DRIVER_MIN_FREQUENCY);
../aax_mixer.c:                  f = be->param(handle->backend.handle,DRIVER_MAX_FREQUENCY);
../aax_mixer.c:                  f = be->param(handle->backend.handle, DRIVER_MAX_SAMPLES);
../aax_mixer.c:               _aaxRingBuffer *rb = handle->ringbuffer;
../aax_mixer.c:                     rv = rb->get_parami(rb, RB_PEAK_VALUE+track);
../aax_mixer.c:                     rv = rb->get_parami(rb, RB_AVERAGE_VALUE+track);
../aax_mixer.c:               dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:                  _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:                     rv = 256*32768*lfo->compression[track];
../aax_mixer.c:               dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:                  _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:                  state =_FILTER_GET_STATE(mixer->props2d, DYNAMIC_GAIN_FILTER);
../aax_mixer.c:                     if (lfo->average[track] <= lfo->gate_threshold) {
../aax_mixer.c:      dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:         int type = filter->pos;
../aax_mixer.c:         switch (filter->type)
../aax_mixer.c:            _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:            _aax2dProps *p2d = mixer->props2d;
../aax_mixer.c:                /* gain min and gain max are read-only for the mixer      */
../aax_mixer.c:            _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:            _aax2dProps *p2d = mixer->props2d;
../aax_mixer.c:            if (filter->type == AAX_DYNAMIC_GAIN_FILTER ||
../aax_mixer.c:                filter->type == AAX_COMPRESSOR)
../aax_mixer.c:               p2d->final.gain_lfo = 1.0f;
../aax_mixer.c:         dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:            _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:            rv = new_filter_handle(handle->info, type, mixer->props2d,
../aax_mixer.c:                                                       mixer->props3d);
../aax_mixer.c:      switch (effect->type)
../aax_mixer.c:         dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:            _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:            _aax2dProps *p2d = mixer->props2d;
../aax_mixer.c:            int type = effect->pos;
../aax_mixer.c:            if ((enum aaxEffectType)effect->type == AAX_DYNAMIC_PITCH_EFFECT)
../aax_mixer.c:               p2d->final.pitch_lfo = 1.0f;
../aax_mixer.c:         dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:            _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:            rv = new_effect_handle(handle->info, type, mixer->props2d,
../aax_mixer.c:                                                       mixer->props3d);
../aax_mixer.c:   if (handle && (VALID_MIXER(handle) || handle->registered_sensors <= 1))
../aax_mixer.c:      if (sframe && !sframe->thread.started && (sframe != handle))
../aax_mixer.c:         if (sframe->mixer_pos == UINT_MAX)
../aax_mixer.c:            dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:               _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:               _intBuffers *hs = mixer->devices;
../aax_mixer.c:                  res = _intBufCreate(&mixer->devices, _AAX_DEVICE);
../aax_mixer.c:                     hs = mixer->devices;
../aax_mixer.c:               if (hs && (mixer->no_registered < mixer->info->max_registered))
../aax_mixer.c:                  mixer->no_registered++;
../aax_mixer.c:                  handle->registered_sensors++;
../aax_mixer.c:               dptr_sframe = _intBufGet(sframe->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:                  dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:                     mixer = sensor->mixer;
../aax_mixer.c:                     submix = sframe_sensor->mixer;
../aax_mixer.c:                     info = submix->info;
../aax_mixer.c:                     mp3d = mixer->props3d;
../aax_mixer.c:                     sp3d = submix->props3d;
../aax_mixer.c:                     info->frequency = mixer->info->frequency;
../aax_mixer.c:                     while (info->frequency > 48000.0f) {
../aax_mixer.c:                        info->frequency /= 2.0f;
../aax_mixer.c:                     info->update_rate = mixer->info->update_rate;
../aax_mixer.c:                     info->period_rate = mixer->info->period_rate;
../aax_mixer.c:                     info->refresh_rate = mixer->info->refresh_rate;
../aax_mixer.c:                     sframe->handle = handle;
../aax_mixer.c:                     sframe->mixer_pos = pos;
../aax_mixer.c:                     submix->refcount++;
../aax_mixer.c:                     rb = submix->ringbuffer;
../aax_mixer.c:                        const _aaxDriverBackend *be = handle->backend.ptr;
../aax_mixer.c:                        rb = be->get_ringbuffer(dt, info->mode);
../aax_mixer.c:                        submix->ringbuffer = rb;
../aax_mixer.c:                        float delay_sec = 1.0f / info->period_rate;
../aax_mixer.c:                        rb->set_format(rb, AAX_PCM24S, AAX_TRUE);
../aax_mixer.c:                        rb->set_paramf(rb, RB_FREQUENCY, info->frequency);
../aax_mixer.c:                        rb->set_parami(rb, RB_NO_TRACKS, info->no_tracks);
../aax_mixer.c:                        duration = rb->get_paramf(rb, RB_DURATION_SEC);
../aax_mixer.c:                        rb->set_paramf(rb, RB_DURATION_SEC, delay_sec*1.0f);
../aax_mixer.c:                         * this would assign memory to rb->tracks before the
../aax_mixer.c:                           rb->init(rb, AAX_TRUE);
../aax_mixer.c:                        rb->set_paramf(rb, RB_DURATION_SEC, delay_sec);
../aax_mixer.c:                        rb->set_state(rb, RB_STARTED);
../aax_mixer.c:      else if (handle->file.ptr == NULL)
../aax_mixer.c:         if (sframe && !sframe->thread.started && (sframe != handle) &&
../aax_mixer.c:             (sframe->backend.ptr == &_aaxStreamDriverBackend))
../aax_mixer.c:            dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:               _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:               dptr_sframe = _intBufGet(sframe->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:                  _aaxAudioFrame *submix = sframe_sensor->mixer;
../aax_mixer.c:                  submix->info->frequency = mixer->info->frequency;
../aax_mixer.c:                  submix->info->period_rate = mixer->info->period_rate;
../aax_mixer.c:                  submix->info->refresh_rate = mixer->info->refresh_rate;
../aax_mixer.c:                  submix->info->update_rate = mixer->info->update_rate;
../aax_mixer.c:                  submix->info->no_tracks = mixer->info->no_tracks;
../aax_mixer.c:                  submix->info->format = mixer->info->format;
../aax_mixer.c:            sframe->handle = handle;
../aax_mixer.c:            handle->file.driver = (char*)sframe;
../aax_mixer.c:            handle->file.handle = sframe->backend.handle;
../aax_mixer.c:            handle->file.ptr = sframe->backend.ptr;
../aax_mixer.c:      if (sframe && sframe->mixer_pos != UINT_MAX)
../aax_mixer.c:         _intBufferData *dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:            _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:            _intBuffers *hs = mixer->devices;
../aax_mixer.c:            _intBufRemove(hs, _AAX_DEVICE, sframe->mixer_pos, AAX_FALSE);
../aax_mixer.c:            mixer->no_registered--;
../aax_mixer.c:            handle->registered_sensors--;
../aax_mixer.c:            dptr_sframe = _intBufGet(sframe->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:               sframe_sensor->mixer->refcount--;
../aax_mixer.c:               sframe->handle = NULL;
../aax_mixer.c:               sframe->mixer_pos = UINT_MAX;
../aax_mixer.c:      else if (handle->file.ptr != NULL)
../aax_mixer.c:         if (sframe && (handle->file.ptr == sframe->backend.ptr))
../aax_mixer.c:            handle->file.ptr = NULL;
../aax_mixer.c:            handle->file.driver = NULL;
../aax_mixer.c:            handle->file.handle = NULL;
../aax_mixer.c:            sframe->handle = NULL;
../aax_mixer.c:      if (emitter && emitter->mixer_pos == UINT_MAX)
../aax_mixer.c:         _aaxEmitter *src = emitter->source;
../aax_mixer.c:         positional = _IS_POSITIONAL(src->props3d);
../aax_mixer.c:         dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:            _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:               he = mixer->emitters_2d;
../aax_mixer.c:               he = mixer->emitters_3d;
../aax_mixer.c:            if (mixer->no_registered < mixer->info->max_registered)
../aax_mixer.c:                  mixer->no_registered++;
../aax_mixer.c:            _aaxEmitter *src = emitter->source;
../aax_mixer.c:            emitter->handle = handle;
../aax_mixer.c:            emitter->mixer_pos = pos;
../aax_mixer.c:            if (_FILTER_GET2D_DATA(emitter->source, FREQUENCY_FILTER)) 
../aax_mixer.c:               aaxFilterSetState(f, filter->slot[0]->state);
../aax_mixer.c:            src->info = handle->info;
../aax_mixer.c:            if (src->update_rate == 0) {
../aax_mixer.c:               src->update_rate = handle->info->update_rate;
../aax_mixer.c:            src->update_ctr = src->update_rate;
../aax_mixer.c:            dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:               _aax3dProps *mp3d, *ep3d = src->props3d;
../aax_mixer.c:               _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:               _aaxRingBuffer *rb = handle->ringbuffer;
../aax_mixer.c:               if (!src->p3dq && VALID_HANDLE(handle)) {
../aax_mixer.c:                  _intBufCreate(&src->p3dq, _AAX_DELAYED3D);
../aax_mixer.c:               if (rb && rb->get_state(rb, RB_IS_VALID)) {
../aax_mixer.c:                  src->props2d->dist_delay_sec = 0.0f;
../aax_mixer.c:                  mp3d = mixer->props3d;
../aax_mixer.c:      if (emitter && emitter->mixer_pos != UINT_MAX)
../aax_mixer.c:         _aaxEmitter *src = emitter->source;
../aax_mixer.c:         dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:            _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:            if (_IS_POSITIONAL(src->props3d))
../aax_mixer.c:               he = mixer->emitters_3d;
../aax_mixer.c:               _PROP_DISTQUEUE_CLEAR_DEFINED(src->props3d);
../aax_mixer.c:               he = mixer->emitters_2d;
../aax_mixer.c:            _intBufRelease(he, _AAX_EMITTER, emitter->mixer_pos);
../aax_mixer.c:            ptr = _intBufRemove(he, _AAX_EMITTER, emitter->mixer_pos,AAX_FALSE);
../aax_mixer.c:               mixer->no_registered--;
../aax_mixer.c:               emitter->handle = NULL;
../aax_mixer.c:               emitter->mixer_pos = UINT_MAX;
../aax_mixer.c:      if (frame && !frame->handle)
../aax_mixer.c:         if (frame->mixer_pos == UINT_MAX)
../aax_mixer.c:            dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:               _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:               _intBuffers *hf = mixer->frames;
../aax_mixer.c:                  unsigned int res = _intBufCreate(&mixer->frames, _AAX_FRAME);
../aax_mixer.c:                     hf = mixer->frames;
../aax_mixer.c:               if (hf && (mixer->no_registered < mixer->info->max_registered))
../aax_mixer.c:                  mixer->no_registered++;
../aax_mixer.c:               dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:                  smixer = sensor->mixer;
../aax_mixer.c:                  fmixer = frame->submix;
../aax_mixer.c:                  mp3d = smixer->props3d;
../aax_mixer.c:                  fp3d = fmixer->props3d;
../aax_mixer.c:                  fmixer->info->period_rate = smixer->info->period_rate;
../aax_mixer.c:                  fmixer->info->refresh_rate = smixer->info->refresh_rate;
../aax_mixer.c:                  fmixer->info->update_rate = smixer->info->update_rate;
../aax_mixer.c:                  fmixer->refcount++;
../aax_mixer.c:                  frame->handle = handle;
../aax_mixer.c:                  frame->mixer_pos = pos;
../aax_mixer.c:         if (frame->handle) put_frame(frame);
../aax_mixer.c:      if (frame && frame->mixer_pos != UINT_MAX)
../aax_mixer.c:         _intBufferData *dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:            _aaxAudioFrame *submix = frame->submix;
../aax_mixer.c:            _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:            _intBuffers *hf = mixer->frames;
../aax_mixer.c:            _intBufRelease(hf, _AAX_FRAME, frame->mixer_pos);
../aax_mixer.c:            _intBufRemove(hf, _AAX_FRAME, frame->mixer_pos, AAX_FALSE);
../aax_mixer.c:            mixer->no_registered--;
../aax_mixer.c:            submix->refcount--;
../aax_mixer.c:            frame->handle = NULL;
../aax_mixer.c:            frame->mixer_pos = UINT_MAX;
../aax_mixer.c:/* -------------------------------------------------------------------------- */
../aax_mixer.c:   _aaxMixerInfo* info = handle->info;
../aax_mixer.c:   float refrate = info->refresh_rate;
../aax_mixer.c:   if ((handle->valid & AAX_TRUE) == 0)
../aax_mixer.c:      const _aaxDriverBackend *be = handle->backend.ptr;
../aax_mixer.c:      void *be_handle = handle->backend.handle;
../aax_mixer.c:      float periodrate = info->period_rate;
../aax_mixer.c:      unsigned ch = info->no_tracks;
../aax_mixer.c:      float freq = info->frequency;
../aax_mixer.c:      int brate = info->bitrate;
../aax_mixer.c:      int fmt = info->format;
../aax_mixer.c:      rssr = (handle->handle) ? AAX_TRUE : AAX_FALSE;
../aax_mixer.c:      res = be->setup(be_handle, &refrate, &fmt, &ch, &freq, &brate,
../aax_mixer.c:            handle->valid |= AAX_TRUE;
../aax_mixer.c:            info->bitrate = brate;
../aax_mixer.c:            info->frequency = freq;
../aax_mixer.c:            info->no_tracks = ch;
../aax_mixer.c:            info->format = fmt;
../aax_mixer.c:            info->period_rate = refrate;
../aax_mixer.c:            old_rate = info->refresh_rate/info->update_rate;
../aax_mixer.c:            info->update_rate = (uint8_t)rintf(refrate/old_rate);
../aax_mixer.c:            // and the new refresh-rate.
../aax_mixer.c:            periods = rintf(refrate/info->refresh_rate);
../aax_mixer.c:            info->refresh_rate = refrate/periods;
../aax_mixer.c:            dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:               _aaxAudioFrame *mixer = sensor->mixer;
../aax_mixer.c:               _aax2dProps *p2d = mixer->props2d;
../aax_mixer.c:               cur = be->param(be_handle, DRIVER_VOLUME);
../aax_mixer.c:      } // be->setup() sets it's own error
../aax_mixer.c:   if (handle && TEST_FOR_FALSE(handle->thread.started)
../aax_mixer.c:       && !handle->handle)
../aax_mixer.c:      handle->thread.ptr = _aaxThreadCreate();
../aax_mixer.c:      assert(handle->thread.ptr != 0);
../aax_mixer.c:      _aaxSignalInit(&handle->thread.signal);
../aax_mixer.c:      assert(handle->thread.signal.condition != 0);
../aax_mixer.c:      assert(handle->thread.signal.mutex != 0);
../aax_mixer.c:      handle->thread.started = AAX_TRUE;
../aax_mixer.c:      ms = rintf(1000/handle->info->period_rate);
../aax_mixer.c:      r = _aaxThreadStart(handle->thread.ptr, handle->backend.ptr->thread,
../aax_mixer.c:            dptr_sensor = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_mixer.c:               r = (handle->ringbuffer != 0);
../aax_mixer.c:            handle->thread.started = AAX_FALSE;
../aax_mixer.c:               _aaxThreadSetPriority(handle->thread.ptr, AAX_HIGHEST_PRIORITY);
../aax_mixer.c:               _aaxThreadSetPriority(handle->thread.ptr, AAX_HIGH_PRIORITY);
../aax_mixer.c:               _aaxThreadSetPriority(handle->thread.ptr, AAX_NORMAL_PRIORITY);
../aax_mixer.c:   else if (_IS_STANDBY(handle) || handle->handle) {
../aax_mixer.c:   if (!handle->handle && TEST_FOR_TRUE(handle->thread.started))
../aax_mixer.c:      handle->thread.started = AAX_FALSE;
../aax_mixer.c:      _aaxSignalTrigger(&handle->thread.signal);
../aax_mixer.c:      _aaxThreadJoin(handle->thread.ptr);
../aax_mixer.c:      _aaxSignalFree(&handle->thread.signal);
../aax_mixer.c:      _aaxThreadDestroy(handle->thread.ptr);
../aax_mixer.c:      if (handle->finished)
../aax_mixer.c:         _aaxSemaphoreDestroy(handle->finished);
../aax_mixer.c:         handle->finished = NULL;
../aax_mixer.c:   else if (handle->handle) {
../aax_mixer.c:   if (!handle->handle && TEST_FOR_TRUE(handle->thread.started))
../aax_mixer.c:      const _aaxDriverBackend *be = handle->backend.ptr;
../aax_mixer.c:      if (be->param(handle->backend.handle, DRIVER_BATCHED_MODE))
../aax_mixer.c:         if (!handle->finished) {
../aax_mixer.c:            handle->finished = _aaxSemaphoreCreate(0);
../aax_mixer.c:         _aaxSemaphoreWait(handle->finished);
../aax_mixer.c:      _aaxSignalTrigger(&handle->thread.signal);
../aax_mixer.c:   else if (handle->handle) {
../aax_scenery.c: * Copyright 2007-2014 by Erik Hofman.
../aax_scenery.c: * Copyright 2009-2014 by Adalin B.V.
../aax_scenery.c:         _intBufferData *dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_scenery.c:            _aaxAudioFrame* mixer = sensor->mixer;
../aax_scenery.c:            mixer->scene.reflection = diffuse_factor;
../aax_scenery.c:         _intBufferData *dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_scenery.c:            _aaxAudioFrame* mixer = sensor->mixer;
../aax_scenery.c:            memcpy(&mixer->scene.dimension, dimension, sizeof(aaxVec3f));
../aax_scenery.c:         _intBufferData *dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_scenery.c:            _aaxAudioFrame* mixer = sensor->mixer;
../aax_scenery.c:            memcpy(&mixer->scene.pos, pos, sizeof(aaxVec3f));
../aax_scenery.c:         dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_scenery.c:            _aaxAudioFrame* mixer = sensor->mixer;
../aax_scenery.c:            int type = filter->pos;
../aax_scenery.c:            switch (filter->type)
../aax_scenery.c:               _aax2dProps *p2d = mixer->props2d;
../aax_scenery.c:               _aax3dProps *p3d = mixer->props3d;
../aax_scenery.c:         dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_scenery.c:            _aaxAudioFrame* mixer = sensor->mixer;
../aax_scenery.c:            rv = new_filter_handle(handle->info, type, mixer->props2d,
../aax_scenery.c:                                                      mixer->props3d);
../aax_scenery.c:         dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_scenery.c:            _aaxAudioFrame* mixer = sensor->mixer;
../aax_scenery.c:            int type = effect->pos;
../aax_scenery.c:            switch (effect->type)
../aax_scenery.c:               _aax3dProps *p3d = mixer->props3d;
../aax_scenery.c:         dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_scenery.c:            _aaxAudioFrame* mixer = sensor->mixer;
../aax_scenery.c:            rv = new_effect_handle(handle->info, type, mixer->props2d,
../aax_scenery.c:                                                      mixer->props3d);
../aax_sensor.c: * Copyright 2007-2014 by Erik Hofman.
../aax_sensor.c: * Copyright 2009-2014 by Adalin B.V.
../aax_sensor.c:      dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_sensor.c:         _aaxAudioFrame* smixer = sensor->mixer;
../aax_sensor.c:         mtx4Copy(smixer->props3d->dprops3d->matrix, mtx);
../aax_sensor.c:         mtx4Copy(smixer->props3d->m_dprops3d->matrix, mtx);
../aax_sensor.c:         _PROP_MTX_SET_CHANGED(smixer->props3d);
../aax_sensor.c:      dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_sensor.c:         _aaxAudioFrame* smixer = sensor->mixer;
../aax_sensor.c:          mtx4Copy(mtx, smixer->props3d->dprops3d->matrix);
../aax_sensor.c:          _PROP_MTX_SET_CHANGED(smixer->props3d);
../aax_sensor.c:      dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_sensor.c:         dp3d = sensor->mixer->props3d->dprops3d;
../aax_sensor.c:         mtx4InverseSimple(dp3d->velocity, mtx);
../aax_sensor.c:         _PROP_SPEED_SET_CHANGED(sensor->mixer->props3d);
../aax_sensor.c:      dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_sensor.c:         dp3d = sensor->mixer->props3d->dprops3d;
../aax_sensor.c:         mtx4InverseSimple(mtx, dp3d->velocity);
../aax_sensor.c:      dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_sensor.c:         _aaxAudioFrame* smixer = sensor->mixer;
../aax_sensor.c:            rv = (unsigned long)(smixer->curr_pos_sec*1e6f);
../aax_sensor.c:            rv = (smixer->curr_sample >= UINT_MAX) ?
../aax_sensor.c:                   UINT_MAX : smixer->curr_sample;
../aax_sensor.c:            dptr_rb = _intBufGet(smixer->play_ringbuffers, _AAX_RINGBUFFER, 0);
../aax_sensor.c:               rv = (smixer->curr_sample >= UINT_MAX) ?
../aax_sensor.c:                      UINT_MAX : smixer->curr_sample;
../aax_sensor.c:               rv *= rb->get_parami(rb, RB_BYTES_SAMPLE);
../aax_sensor.c:      dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_sensor.c:         _aaxAudioFrame* smixer = sensor->mixer;
../aax_sensor.c:         _intBuffers *dptr_rb = smixer->play_ringbuffers;
../aax_sensor.c:               buf->id = BUFFER_ID;
../aax_sensor.c:               buf->ref_counter = 1;
../aax_sensor.c:               buf->blocksize = 1;
../aax_sensor.c:               buf->pos = 0;
../aax_sensor.c:               buf->format = rb->get_parami(rb, RB_FORMAT);
../aax_sensor.c:               buf->frequency = rb->get_paramf(rb, RB_FREQUENCY);
../aax_sensor.c:               buf->mipmap = AAX_FALSE;
../aax_sensor.c:               buf->info = &_info;
../aax_sensor.c:               rb->set_parami(rb, RB_IS_MIXER_BUFFER, AAX_FALSE);
../aax_sensor.c:               buf->ringbuffer = rb;
../aax_sensor.c:      dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_sensor.c:         _intBuffers *ringbuffers = sensor->mixer->play_ringbuffers;
../aax_sensor.c:         rv = _aaxSignalWaitTimed(&handle->buffer_ready, timeout);
../aax_sensor.c:         if ((handle->info->mode == AAX_MODE_READ) && !handle->handle) {
../aax_sensor.c:         else if (handle->handle)	/* registered sensor */
../aax_sensor.c:            dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_sensor.c:               sensor->mixer->capturing = AAX_TRUE;
../aax_sensor.c:         if ((handle->info->mode == AAX_MODE_READ) && !handle->handle) {
../aax_sensor.c:         else if (handle->handle)	/* registered sensor */
../aax_sensor.c:         else if (handle->sensors)		/* capture buffer on playback */
../aax_sensor.c:            dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_sensor.c:               sensor->mixer->capturing = AAX_FALSE;
../aax_sensor.c:/* -------------------------------------------------------------------------- */
../aax_sensor.c:   if ((handle->info->mode != AAX_MODE_READ) ||
../aax_sensor.c:       (handle->thread.started != AAX_FALSE)) {
../aax_sensor.c:   dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_sensor.c:      _aaxAudioFrame *submix = sensor->mixer;
../aax_sensor.c:      _aaxMixerInfo* info = submix->info;
../aax_sensor.c:      if (!submix->ringbuffer)
../aax_sensor.c:         const _aaxDriverBackend *be = handle->backend.ptr;
../aax_sensor.c:         enum aaxRenderMode mode = info->mode;
../aax_sensor.c:         submix->ringbuffer = be->get_ringbuffer(dt, mode);
../aax_sensor.c:      rb = submix->ringbuffer;
../aax_sensor.c:         float delay_sec = 1.0f / info->period_rate;
../aax_sensor.c:         rb->set_format(rb, AAX_PCM24S, AAX_TRUE);
../aax_sensor.c:         rb->set_parami(rb, RB_NO_TRACKS, info->no_tracks);
../aax_sensor.c:         be = handle->backend.ptr;
../aax_sensor.c:         min = be->param(handle->backend.handle, DRIVER_MIN_VOLUME);
../aax_sensor.c:         max = be->param(handle->backend.handle, DRIVER_MAX_VOLUME);
../aax_sensor.c:         rb->set_paramf(rb, RB_VOLUME_MIN, min);
../aax_sensor.c:         rb->set_paramf(rb, RB_VOLUME_MAX, max);
../aax_sensor.c:*/       rb->set_paramf(rb, RB_FREQUENCY, info->frequency);
../aax_sensor.c:         rb->set_paramf(rb, RB_DURATION_SEC, delay_sec*1.0f);
../aax_sensor.c:         rb->init(rb, AAX_TRUE);
../aax_sensor.c:         rb->set_paramf(rb, RB_DURATION_SEC, delay_sec);
../aax_sensor.c:         rb->set_state(rb, RB_STARTED);
../aax_sensor.c:   assert(handle->info->mode == AAX_MODE_READ);
../aax_sensor.c:   assert(handle->thread.started == AAX_FALSE);
../aax_sensor.c:      const _aaxDriverBackend *be = handle->backend.ptr;
../aax_sensor.c:      if (be->thread)
../aax_sensor.c:         handle->thread.ptr = _aaxThreadCreate();
../aax_sensor.c:         assert(handle->thread.ptr != 0);
../aax_sensor.c:         _aaxSignalInit(&handle->thread.signal);
../aax_sensor.c:         assert(handle->thread.signal.condition != 0);
../aax_sensor.c:         assert(handle->thread.signal.mutex != 0);
../aax_sensor.c:         handle->thread.started = AAX_TRUE;
../aax_sensor.c:         ms = rintf(1000/handle->info->period_rate);
../aax_sensor.c:         r = _aaxThreadStart(handle->thread.ptr,
../aax_sensor.c:                             handle->backend.ptr->thread, handle, ms);
../aax_sensor.c:         r = _aaxThreadStart(handle->thread.ptr, _aaxSoftwareMixerThread,
../aax_sensor.c:               r = (handle->ringbuffer != 0);
../aax_sensor.c:               handle->thread.started = AAX_FALSE;
../aax_sensor.c:               dptr = _intBufGet(handle->sensors, _AAX_SENSOR, 0);
../aax_sensor.c:                  sensor->mixer->capturing = AAX_TRUE;
../aax_sensor.c:   if TEST_FOR_TRUE(handle->thread.started)
../aax_sensor.c:      if (handle->info->mode == AAX_MODE_READ)
../aax_sensor.c:         handle->thread.started = AAX_FALSE;
../aax_sensor.c:         _aaxSignalTrigger(&handle->thread.signal);
../aax_sensor.c:         _aaxThreadJoin(handle->thread.ptr);
../aax_sensor.c:         _aaxSignalFree(&handle->thread.signal);
../aax_sensor.c:         _aaxThreadDestroy(handle->thread.ptr);
../aax_sensor.c:         dptr = _intBufGetNoLock(handle->sensors, _AAX_SENSOR, 0);
../aax_sensor.c:            sensor->mixer->capturing = AAX_FALSE;
../aax_support.c: * Copyright 2007-2014 by Erik Hofman.
../aax_support.c: * Copyright 2009-2014 by Adalin B.V.
../aax_support.c:         for(i=0; i<AAX_FILTER_MAX-1; i++)
../aax_support.c:            if (!strcasecmp(filter, _aaxFilters[i]->name))
../aax_support.c:               if (_aaxFilters[i]->lite || VALID_HANDLE(handle)) {
../aax_support.c:       rv =  _aaxFilters[type-1]->name;
../aax_support.c:         for(i=0; i<AAX_EFFECT_MAX-1; i++)
../aax_support.c:            if (!strcasecmp(effect, _aaxEffects[i]->name))
../aax_support.c:               if (_aaxEffects[i]->lite || VALID_HANDLE(handle)) {
../aax_support.c:       rv =  _aaxEffects[type-1]->name;
../aax_support.c:         if (ptr->id == HANDLE_ID) rv = AAX_TRUE;
../aax_support.c:          if (ptr->id == HANDLE_ID && VALID_HANDLE(ptr)) rv = AAX_TRUE;
../aax_support.c:         if (ptr->id == BUFFER_ID) rv = AAX_TRUE;
../aax_support.c:         if (ptr->id == EMITTER_ID) rv = AAX_TRUE;
../aax_support.c:         if (ptr->id == AUDIOFRAME_ID) rv = AAX_TRUE;
../aax_support.c:         if (ptr->id == FILTER_ID) rv = AAX_TRUE;
../aax_support.c:         if (ptr->id == EFFECT_ID) rv = AAX_TRUE;
../aax_support.c:/* -------------------------------------------------------------------------- */
../api.c: * Copyright 2011-2014 by Erik Hofman.
../api.c: * Copyright 2011-2014 by Adalin B.V.
../api.c:      len = ptr - _str;
../api.c:      memcpy(*backend, _str, ptr - _str);
../api.c:      len = strlen(ptr)-strlen(" on ");
../api.c:      memcpy(*device, _str, ptr - _str);
../api.h: * Copyright 2007-2014 by Erik Hofman.
../api.h: * Copyright 2009-2014 by Adalin B.V.
../api.h://#define EBF_VALID(a)		((a)->info && ((a)->info)->id == INFO_ID)
../api.h:#define EBF_VALID(a)		((a)->info && VALID_HANDLE((_handle_t*)((a)->info)->backend))
../api.h:/* --- Error support -- */
../api.h:/* --- Sensor --- */
../api.h:/* --- Driver --- */
../api.h:#define VALID_LITE_HANDLE(h)	((h) && (((h)->valid & ~AAX_TRUE)==LITE_HANDLE_ID || ((h)->valid & ~AAX_TRUE) == HANDLE_ID))
../api.h:#define VALID_HANDLE(h)		((h) && ((h)->valid & ~AAX_TRUE) == HANDLE_ID)
../api.h:#define VALID_MIXER(h)		(VALID_HANDLE(h) && ((h)->valid & AAX_TRUE))
../api.h:/* --- AudioFrame --- */
../api.h:/* --- Instrument --- */
../api.h:/* --- Buffer --- */
../api.h:#define BLOCKSIZE_TO_SMP(a)		((a) > 1) ? (((a)-4)*2) : 1
../api.h:/* --- Emitter --- */
../api.h:/* -- Filters and Effects -- */
../api.h:/* --- Events --- */
../api.h:/* --- WaveForms --- */
../api.h:/* --- Logging --- */
../api.h:# define DBG_TESTNAN(a, b)		do { int i; for (i=0;i<(b);i++) if (is_nan((a)[i])) { printf("%s line %i\n\tNaN detetced at pos %i\n", __FILE__, __LINE__, i); exit(-1); } } while(0);
../api.h:             WRITE_BUFFER_TO_FILE(dptr-ds, ds+no_samples); } }
../api.h:/* --- System Specific & Config file related  --- */
../arch.h: * Copyright 2007-2014 by Erik Hofman.
../arch.h: * Copyright 2009-2014 by Adalin B.V.
../devices.c: * Copyright 2005-2014 by Erik Hofman.
../devices.c: * Copyright 2009-2014 by Adalin B.V.
../devices.c:            assert(be->detect);
../devices.c:            printf("Backend #%i: '%s'\n", i, be->driver);
../devices.c:            if (be->detect(AAX_MODE_WRITE_STEREO) || be->detect(AAX_MODE_READ))
../devices.c:            res = strcasecmp(b->driver, name);
../devices.c:   while (i--)
../devices.c:      if (be->detect(AAX_MODE_WRITE_STEREO) &&
../devices.c:          be->state(NULL, DRIVER_SUPPORTS_PLAYBACK))
../devices.c:         if (!strcasecmp(found_be->driver, name))
../devices.c:   while(i--)
../devices.c:      if (be->detect(AAX_MODE_READ) &&
../devices.c:          be->state(NULL, DRIVER_SUPPORTS_CAPTURE))
../devices.c:      dptr = _intBufGetNoLock(bs, _AAX_BACKEND, num-pos-1);
../devices.c:   return be->driver;
../devices.c:         config->no_backends = num;
../devices.c:               if (!strcasecmp(devname[0], be->driver))
../devices.c:                  config->backend.driver = _aax_strdup(be->driver);
../devices.c:                  config->backend.input = 0;
../devices.c:                  config->backend.output = 0;
../devices.c:      config->node[0].devname = NULL;
../devices.c:      config->node[0].frequency = 44100;
../devices.c:      config->node[0].setup = _aax_strdup("stereo");
../devices.c:      config->no_nodes = 1;
../devices.c:      config->node[0].interval = 66;
../devices.c:      config->node[0].update = 50;
../devices.c:      config->node[0].hrtf = 0;
../devices.c:      config->node[0].no_speakers = 2;
../devices.c:         config->backend.driver = _aax_strdup(be->driver);
../devices.c:               free(config->node[0].devname);
../devices.c:               config->node[0].devname = _aax_strdup(dev);
../devices.c:      config->no_nodes = num;
../devices.c:                  free(config->node[n].devname);
../devices.c:                  config->node[n].devname = _aax_strdup(dev);
../devices.c:               i = xmlNodeGetBool(xoid, "tube-compressor");
../devices.c:               free(config->node[n].setup);
../devices.c:               config->node[n].setup = _aax_strdup(setup);
../devices.c:            config->node[n].hrtf = xmlNodeCopy(xoid, "head");
../devices.c:            f = (float)xmlNodeGetDouble(xoid, "frequency-hz");
../devices.c:            if (f) config->node[n].frequency = f;
../devices.c:            f = (float)xmlNodeGetDouble(xoid, "interval-hz");
../devices.c:            if (f) config->node[n].interval = f;
../devices.c:            f = (float)xmlNodeGetDouble(xoid, "update-hz");
../devices.c:            if (f) config->node[n].update = f;
../devices.c:            i = xmlNodeGetInt(xoid, "max-emitters");
../devices.c:            if (i) config->node[n].no_emitters = i;
../devices.c:      curlevel = -1;
../devices.c:      snprintf((char*)device_name, 255, "%s", config->backend.driver);
../devices.c:               ssize_t q, i, l, index = -1;
../devices.c:               ptr = config->backend.driver;
../devices.c:                  if (tmp) q = tmp-ptr;
../devices.c:                  config->backend.driver = malloc(l);
../devices.c:                  snprintf(config->backend.driver, q, "%s", ptr);	
../devices.c:                  strcat(config->backend.driver, " on ");
../devices.c:                  strcat(config->backend.driver, rr[0]);   /* device name    */
../devices.c:                  strcat(config->backend.driver, ": ");
../devices.c:                  strcat(config->backend.driver, rr[1]);   /* interface name */
../devices.c:                  xmlFree(config->backend.output);
../devices.c:                  config->backend.output = xmlNodeCopyPos(xdid, xiid, "connector", con);
../devices.c:                  xmlFree(config->backend.input);
../devices.c:                  config->backend.input = xmlNodeCopyPos(xdid, xiid, "connector", con);
../devices.c:               if (i) config->node[0].bitrate = i;
../devices.c:               f = (float)xmlNodeGetDouble(xiid, "frequency-hz");
../devices.c:               if (f) config->node[0].frequency = f;
../devices.c:               f = (float)xmlNodeGetDouble(xiid, "interval-hz");
../devices.c:               if (f) config->node[0].interval = f;
../devices.c:                  free(config->node[0].setup);
../devices.c:                  config->node[0].setup = _aax_strdup(ptr);
../devices.c:                  config->node[0].no_speakers = i;
../devices.c:                      xmlFree(config->node[0].hrtf);
../devices.c:                      config->node[0].hrtf = xmlNodeCopy(xiid, "hrtf");
../devices.c:                     xmlFree(config->node[0].speaker[index]);
../devices.c:                     config->node[0].speaker[index] = ptr;
../devices.c:   for (i=0; i<config->no_nodes; i++)
../devices.c:      free(config->node[i].setup);
../devices.c:      free(config->node[i].devname);
../devices.c:      xmlFree(config->node[i].hrtf);
../devices.c:      for (q=0; q<config->node[i].no_speakers; q++) {
../devices.c:         xmlFree(config->node[i].speaker[q]);
../devices.c:   free(config->backend.driver);
../devices.c:   xmlFree(config->backend.input);
../devices.c:   xmlFree(config->backend.output);
../devices.c:/* -------------------------------------------------------------------------- */
../devices.c:            if ((dptr-devname[1]) == (rrptr-rr)) level = 3;
../devices.c:      snprintf((char*)driver_name, 255, "%s", config->backend.driver);
../devices.c:                  ssize_t q, i, l, index = -1;
../devices.c:                  ptr = config->backend.driver;
../devices.c:                     if (tmp) q = tmp-ptr;
../devices.c:                     config->backend.driver = malloc(l);
../devices.c:                     snprintf(config->backend.driver, q, "%s", ptr);
../devices.c:                     strcat(config->backend.driver, " on ");
../devices.c:                     strcat(config->backend.driver, rr);
../devices.c:                  xmlFree(config->backend.output);
../devices.c:                  config->backend.output = output;
../devices.c:                  f = (float)xmlNodeGetDouble(output, "frequency-hz");
../devices.c:                  if (f) config->node[0].frequency = f;
../devices.c:                  f = (float)xmlNodeGetDouble(output, "interval-hz");
../devices.c:                  if (f) config->node[0].interval = f;
../devices.c:                  config->node[0].no_speakers = i;
../devices.c:                     free(config->node[0].setup);
../devices.c:                     config->node[0].setup = _aax_strdup(ptr);
../devices.c:                     xmlFree(config->node[0].speaker[index]);
../devices.c:                     config->node[0].speaker[index] = ptr;
../devices.c:                  ptr = config->backend.driver;
../devices.c:                     if (tmp) q = tmp-ptr;
../devices.c:                     config->backend.driver = malloc(l);
../devices.c:                     snprintf(config->backend.driver, q, "%s", ptr);
../devices.c:                     strcat(config->backend.driver, " on ");
../devices.c:                     strcat(config->backend.driver, rr);
../devices.c:                  xmlFree(config->backend.input);
../devices.c:                  config->backend.input = input;
../devices.c:                  f = (float)xmlNodeGetDouble(input, "frequency-hz");
../devices.c:                  if (f) config->node[0].frequency = f;
../devices.c:                  f = (float)xmlNodeGetDouble(input, "interval-hz");
../devices.c:                  if (f) config->node[0].interval = f;
../devices.c:                     free(config->node[0].setup);
../devices.c:                     config->node[0].setup = _aax_strdup(ptr);
../devices.h: * Copyright 2005-2014 by Erik Hofman.
../devices.h: * Copyright 2009-2014 by Adalin B.V.
../driver.h: * Copyright 2005-2014 by Erik Hofman.
../driver.h: * Copyright 2009-2014 by Adalin B.V.
../driver.h:#define AAX_LIBRARY_STR			"AeonWave-HD"
../driver.h:#define AAX_LIBRARY_STR_LT		"AeonWave-Lite"
../driver.h:				AAX_MKSTR(AAX_MICRO_VERSION)"-" \
../driver.h:/* ---  software device helper functions --- */
../info:software/device.c:   dt = 1.0f/frame->info->period_rate;
../info:software/device.c:   he = frame->emitters_3d;
../info:software/device.c:         he = frame->emitters_2d;
../info:software/frame.c:      _aaxAudioFrame *sfmixer = subframe->submix;
../info:software/frame.c:   _aax3dProps* fp3d = frame->props3d;
../info:software/frame.c:      _aax2dProps* fp2d = frame->props2d;
../info:software/frame.c:      _intBufAddData(frame->p3dq, _AAX_DELAYED3D, fdp3d);
../info:software/frame.c:      if (frame->curr_pos_sec > fp2d->dist_delay_sec)
../info:software/frame.c:               buf3dq = _intBufPop(frame->p3dq, _AAX_DELAYED3D);
../info:stream/fmt_flac.c:      num = frame->header.blocksize*8/(handle->no_tracks*handle->bits_sample);
../info:stream/fmt_flac.c:      if (frame->header.blocksize <= handle->flacBufSize) {
../objects.c: * Copyright 2005-2014 by Erik Hofman.
../objects.c: * Copyright 2009-2014 by Adalin B.V.
../objects.c:   _aax_memcpy(&info->hrtf, &_aaxContextDefaultHead, size);
../objects.c:   _aax_memcpy(&info->speaker, &_aaxContextDefaultSpeakersVolume, size);
../objects.c:   info->delay = &info->speaker[_AAX_MAX_SPEAKERS];
../objects.c:   _aax_memcpy(info->delay, &_aaxContextDefaultSpeakersDelay, size);
../objects.c:   size = _AAX_MAX_SPEAKERS-1;
../objects.c:      info->router[size] = size;
../objects.c:   } while (size--);
../objects.c:   info->no_tracks = 2;
../objects.c:   info->track = AAX_TRACK_ALL;
../objects.c:   info->pitch = 1.0f;
../objects.c:   info->frequency = 48000.0f;
../objects.c:   info->period_rate = 20.0f;
../objects.c:   info->refresh_rate = 20.0f;
../objects.c:   info->format = AAX_PCM16S;
../objects.c:   info->mode = AAX_MODE_WRITE_STEREO;
../objects.c:   info->max_emitters = _AAX_MAX_MIXER_REGISTERED;
../objects.c:   info->max_registered = 0;
../objects.c:   info->bitrate = 320;
../objects.c:   info->update_rate = 0;
../objects.c:   info->id = INFO_ID;
../objects.c:   info->backend = handle;
../objects.c:   memset(p2d->speaker, 0, 2*size);
../objects.c:   memset(p2d->head, 0, size);
../objects.c:   memset(p2d->hrtf, 0, size);
../objects.c:   memset(p2d->hrtf_prev, 0, size);
../objects.c:      _aaxSetDefaultFilter2d(&p2d->filter[pos], pos);
../objects.c:      _aaxSetDefaultEffect2d(&p2d->effect[pos], pos);
../objects.c:   memset(&p2d->prev_gain, 0, size);
../objects.c:   p2d->prev_freq_fact = 0.0f;
../objects.c:   p2d->dist_delay_sec = 0.0f;
../objects.c:   p2d->bufpos3dq = 0.0f;
../objects.c:   p2d->curr_pos_sec = 0.0f;		/* MIDI */
../objects.c:   p2d->note.velocity = 1.0f;
../objects.c:   p2d->note.pressure = 1.0f;
../objects.c:   p2d->final.pitch_lfo = 1.0f;		/* LFO */
../objects.c:   p2d->final.pitch = 1.0f;
../objects.c:   p2d->final.gain_lfo = 1.0f;
../objects.c:   p2d->final.gain = 1.0f;
../objects.c:   mtx4Copy(dp3d->matrix, aaxIdentityMatrix);
../objects.c:   mtx4Copy(dp3d->velocity, aaxIdentityMatrix);
../objects.c:   dp3d->state3d = 0;
../objects.c:   dp3d->pitch = 1.0f;
../objects.c:   dp3d->gain = 1.0f;
../objects.c:      rv->m_dprops3d = (_aaxDelayed3dProps*)ptr2;
../objects.c:      rv->dprops3d = _aax_aligned_alloc16(sizeof(_aaxDelayed3dProps));
../objects.c:      if (rv->dprops3d)
../objects.c:         _aaxSetDefaultDelayed3dProps(rv->dprops3d);
../objects.c:         _aaxSetDefaultDelayed3dProps(rv->m_dprops3d);
../objects.c:            _aaxSetDefaultFilter3d(&rv->filter[pos], pos);
../objects.c:            _aaxSetDefaultEffect3d(&rv->effect[pos], pos);
../objects.c:/* -------------------------------------------------------------------------- */
../objects.c: * Left-right time difference (delay):
../objects.c: * Angle from ahead (azimuth, front = 0deg): (ear-distance)
../objects.c: *     0 deg =  0.00 ms,                                -- ahead      --
../objects.c: *    90 deg =  0.64 ms,				-- right/left --
../objects.c: *   180 deg =  0.00 ms 				-- back       --
../objects.c: *     0 deg = 0.325 ms,                                -- below  --
../objects.c: *    90 deg = 0.175 ms,                                -- center --
../objects.c: *   180 deg = 0.100 ms                                 -- above  --
../objects.c: * The inner pinna ridge which determine front-back directions in the
../objects.c: * horizontal plane. Front-back istinctions are not uniquely determined
../objects.c: *     0 deg =  0.080 ms,				-- ahead  --
../objects.c: *    90 deg =  0.015 ms,				-- center --
../objects.c: *   135+deg =  0.000 ms				-- back   --
../objects.c:   { 0.000640f,-0.000110f, 0.000065f, 0.0f },	/* head delay factors */
../objects.c:   /* left headphone shell (volume)                          --- */
../objects.c:   { 0.33f, 0.00f, 0.00f, 1.0f }, 	 /* left-right           */
../objects.c:   { 0.00f,-1.00f, 0.00f, 1.0f }, 	 /* up-down              */
../objects.c:   { 0.00f, 0.00f, 0.33f, 1.0f }, 	 /* back-front           */
../objects.c:   /* right headphone shell (volume)                         --- */
../objects.c:   {-0.33f, 0.00f, 0.00f, 1.0f }, 	 /* left-right           */
../objects.c:   { 0.00f,-1.00f, 0.00f, 1.0f }, 	 /* up-down              */
../objects.c:   { 0.00f, 0.00f, 0.33f, 1.0f }, 	 /* back-front           */
../objects.c:   /* left headphone shell (delay)                           --- */
../objects.c:   {-1.00f, 0.00f, 0.00f, 0.0f },        /* left-right           */
../objects.c:   { 0.00f,-1.00f, 0.00f, 0.0f },        /* up-down              */
../objects.c:   { 0.00f, 0.00f, 1.00f, 0.0f },        /* back-front           */
../objects.c:   /* right headphone shell (delay)                          --- */
../objects.c:   { 1.00f, 0.00f, 0.00f, 0.0f },        /* left-right           */
../objects.c:   { 0.00f,-1.00f, 0.00f, 0.0f },        /* up-down              */
../objects.c:   { 0.00f, 0.00f, 1.00f, 0.0f },        /* back-front           */
../objects.c:   {-1.00f, 0.00f, 1.00f, 1.0f },	/* front right speaker   */
../objects.c:   { 1.00f, 0.00f,-1.00f, 1.0f },	/* rear left speaker     */
../objects.c:   {-1.00f, 0.00f,-1.00f, 1.0f },	/* rear right speaker    */
../objects.c:   {-1.00f, 0.00f, 0.00f, 1.0f }	/* right side speaker    */
../objects.c:      unsigned int _src = _sources - num;
../objects.c:   return _aaxGetSetMonoSources(0, -1);
../objects.h: * Copyright 2005-2014 by Erik Hofman.
../objects.h: * Copyright 2009-2014 by Adalin B.V.
../objects.h:   exit(-1); \
../objects.h:#define _IS_PLAYING(q)       (((q)->state & _STATE_PLAYING_MASK) == 0)
../objects.h:#define _IS_INITIAL(q)       (((q)->state & _STATE_INITIAL) == _STATE_INITIAL)
../objects.h:#define _IS_STANDBY(q)       (((q)->state & _STATE_INITIAL) == _STATE_INITIAL)
../objects.h:#define _IS_STOPPED(q)       (((q)->state & _STATE_INITIAL) == _STATE_STOPPED)
../objects.h:#define _IS_PAUSED(q)        (((q)->state & _STATE_INITIAL) == _STATE_PAUSED)
../objects.h:#define _IS_PROCESSED(q)     (((q)->state & _STATE_PLAYING_MASK) == _STATE_PROCESSED)
../objects.h:#define _IS_LOOPING(q)       ((q)->state & _STATE_LOOPING)
../objects.h:#define _IS_RELATIVE(q)      ((q)->state & _STATE_RELATIVE)
../objects.h:#define _IS_POSITIONAL(q)    ((q)->state & _STATE_POSITIONAL)
../objects.h:#define _SET_INITIAL(q)      ((q)->state |= _STATE_INITIAL)
../objects.h:#define _SET_STANDBY(q)      ((q)->state |= _STATE_INITIAL)
../objects.h:#define _SET_PLAYING(q)      ((q)->state &= ~_STATE_INITIAL)
../objects.h:#define _SET_STOPPED(q)      ((q)->state |= _STATE_STOPPED)
../objects.h:#define _SET_PAUSED(q)       ((q)->state |= _STATE_PAUSED)
../objects.h:#define _SET_LOOPING(q)      ((q)->state |= _STATE_LOOPING)
../objects.h:#define _SET_PROCESSED(q)    ((q)->state |= _STATE_PROCESSED)
../objects.h:#define _SET_RELATIVE(q)     ((q)->state |= _STATE_RELATIVE)
../objects.h:#define _SET_POSITIONAL(q)   ((q)->state |= _STATE_POSITIONAL)
../objects.h:#define _TAS_PLAYING(q,r)     _STATE_TAS((q)->state, (r), _STATE_INITIAL)
../objects.h:#define _TAS_PAUSED(q,r)      _STATE_TAS((q)->state, (r), _STATE_PAUSED)
../objects.h:#define _TAS_LOOPING(q,r)     _STATE_TAS((q)->state, (r), _STATE_LOOPING)
../objects.h:#define _TAS_PROCESSED(q,r)   _STATE_TAS((q)->state, (r), _STATE_PROCESSED)
../objects.h:#define _TAS_RELATIVE(q,r)    _STATE_TAS((q)->state, (r), _STATE_RELATIVE)
../objects.h:#define _TAS_POSITIONAL(q,r)  _STATE_TAS((q)->state, (r), _STATE_POSITIONAL)
../objects.h:#define _PROP3D_CLEAR(q)                ((q)->state3d &= (CONE_DEFINED|DYNAMIC_PITCH_DEFINED))
../objects.h:#define _PROP3D_PITCH_HAS_CHANGED(q)    ((q)->state3d & PITCH_CHANGE)
../objects.h:#define _PROP3D_GAIN_HAS_CHANGED(q)     ((q)->state3d & GAIN_CHANGED)
../objects.h:#define _PROP3D_DIST_HAS_CHANGED(q)     ((q)->state3d & DIST_CHANGED)
../objects.h:#define _PROP3D_MTX_HAS_CHANGED(q)      ((q)->state3d & MTX_CHANGED)
../objects.h:#define _PROP3D_SPEED_HAS_CHANGED(q)    ((q)->state3d & SPEED_CHANGED)
../objects.h:#define _PROP3D_MTXSPEED_HAS_CHANGED(q) ((q)->state3d & (SPEED_CHANGED|MTX_CHANGED))
../objects.h:#define _PROP3D_CONE_IS_DEFINED(q)      ((q)->state3d & CONE_DEFINED)
../objects.h:#define _PROP3D_PITCH_SET_CHANGED(q)    ((q)->state3d |= PITCH_CHANGED)
../objects.h:#define _PROP3D_GAIN_SET_CHANGED(q)     ((q)->state3d |= GAIN_CHANGED)
../objects.h:#define _PROP3D_DIST_SET_CHANGED(q)     ((q)->state3d |= DIST_CHANGED)
../objects.h:#define _PROP3D_MTX_SET_CHANGED(q)      ((q)->state3d |= MTX_CHANGED)
../objects.h:#define _PROP3D_SPEED_SET_CHANGED(q)    ((q)->state3d |= SPEED_CHANGED)
../objects.h:#define _PROP3D_CONE_SET_DEFINED(q)     ((q)->state3d |= CONE_DEFINED)
../objects.h:#define _PROP3D_DYNAMIC_PITCH_SET_DEFINED(q) ((q)->state3d |= DYNAMIC_PITCH_DEFINED)
../objects.h:#define _PROP3D_PITCH_CLEAR_CHANGED(q)  ((q)->state3d &= ~PITCH_CHANGED)
../objects.h:#define _PROP3D_GAIN_CLEAR_CHANGED(q)   ((q)->state3d &= ~GAIN_CHANGED)
../objects.h:#define _PROP3D_DIST_CLEAR_CHANGED(q)   ((q)->state3d &= ~DIST_CHANGED)
../objects.h:#define _PROP3D_MTX_CLEAR_CHANGED(q)    ((q)->state3d &= ~MTX_CHANGED)
../objects.h:#define _PROP3D_SPEED_CLEAR_CHANGED(q)  ((q)->state3d &= ~SPEED_CHANGED)
../objects.h:#define _PROP3D_CONE_CLEAR_DEFINED(q)   ((q)->state3d &= ~CONE_DEFINED)
../objects.h:#define _PROP3D_DYNAMIC_PITCH_CLEAR_DEFINED(q) ((q)->state3d &= ~DYNAMIC_PITCH_DEFINED)
../objects.h:#define _PROP3D_SCENE_IS_DEFINED(q)     ((q)->state3d & SCENE_CHANGED)
../objects.h:#define _PROP3D_REVERB_IS_DEFINED(q)    ((q)->state3d & REVERB_CHANGED)
../objects.h:#define _PROP3D_DISTDELAY_IS_DEFINED(q) ((q)->state3d & DISTDELAY_CHANGED)
../objects.h:#define _PROP3D_DISTQUEUE_IS_DEFINED(q) ((q)->state3d & DISTQUEUE_CHANGED)
../objects.h:#define _PROP3D_WIND_IS_DEFINED(q)      ((q)->state3d & WIND_CHANGED)
../objects.h:#define _PROP3D_SCENE_SET_CHANGED(q)    ((q)->state3d |= SCENE_CHANGED)
../objects.h:#define _PROP3D_REVERB_SET_CHANGED(q)   ((q)->state3d |= REVERB_CHANGED)
../objects.h:#define _PROP3D_DISTDELAY_SET_DEFINED(q) ((q)->state3d |= DISTDELAY_CHANGED)
../objects.h:#define _PROP3D_DISTQUEUE_SET_DEFINED(q) ((q)->state3d |= (DISTQUEUE_CHANGED|DISTDELAY_CHANGED))
../objects.h:#define _PROP3D_WIND_SET_CHANGED(q)     ((q)->state3d |= WIND_CHANGED)
../objects.h:#define _PROP3D_SCENE_CLEAR_CHANGED(q)  ((q)->state3d &= ~SCENE_CHANGED)
../objects.h:#define _PROP3D_REVERB_CLEAR_CHANGED(q) ((q)->state3d &= ~REVERB_CHANGED)
../objects.h:#define _PROP3D_DISTDELAY_CLEAR_DEFINED(q) ((q)->state3d &= ~DISTDELAY_CHANGED)
../objects.h:#define _PROP3D_DISTQUEUE_CLEAR_DEFINED(q) ((q)->state3d &= ~(DISTQUEUE_CHANGED|DISTDELAY_CHANGED))
../objects.h:#define _PROP3D_WIND_CLEAR_CHANGED(q)   ((q)->state3d &= ~WIND_CHANGED)
../objects.h:#define _PROP_CLEAR(q)                  _PROP3D_CLEAR((q)->dprops3d)
../objects.h:#define _PROP_PITCH_HAS_CHANGED(q)      _PROP3D_PITCH_HAS_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_GAIN_HAS_CHANGED(q)       _PROP3D_GAIN_HAS_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_DIST_HAS_CHANGED(q)       _PROP3D_DIST_HAS_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_MTX_HAS_CHANGED(q)        _PROP3D_MTX_HAS_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_SPEED_HAS_CHANGED(q)      _PROP3D_SPEED_HAS_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_CONE_IS_DEFINED(q)        _PROP3D_CONE_IS_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_PITCH_SET_CHANGED(q)      _PROP3D_PITCH_SET_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_GAIN_SET_CHANGED(q)       _PROP3D_GAIN_SET_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_DIST_SET_CHANGED(q)       _PROP3D_DIST_SET_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_MTX_SET_CHANGED(q)        _PROP3D_MTX_SET_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_SPEED_SET_CHANGED(q)      _PROP3D_SPEED_SET_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_CONE_SET_DEFINED(q)       _PROP3D_CONE_SET_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_DYNAMIC_PITCH_SET_DEFINED(q) _PROP3D_DYNAMIC_PITCH_SET_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_PITCH_CLEAR_CHANGED(q)    _PROP3D_PITCH_CLEAR_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_GAIN_CLEAR_CHANGED(q)     _PROP3D_GAIN_CLEAR_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_DIST_CLEAR_CHANGED(q)     _PROP3D_DIST_CLEAR_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_MTX_CLEAR_CHANGED(q)      _PROP3D_MTX_CLEAR_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_SPEED_CLEAR_CHANGED(q)    _PROP3D_SPEED_CLEAR_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_CONE_CLEAR_DEFINED(q)     _PROP3D_CONE_CLEAR_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_DYNAMIC_PITCH_CLEAR_DEFINED(q) _PROP3D_DYNAMIC_PITCH_CLEAR_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_SCENE_IS_DEFINED(q)       _PROP3D_SCENE_IS_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_REVERB_IS_DEFINED(q)      _PROP3D_REVERB_IS_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_DISTDELAY_IS_DEFINED(q)   _PROP3D_DISTDELAY_IS_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_DISTQUEUE_IS_DEFINED(q)   _PROP3D_DISTQUEUE_IS_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_WIND_IS_DEFINED(q)        _PROP3D_WIND_IS_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_SCENE_SET_CHANGED(q)      _PROP3D_SCENE_SET_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_REVERB_SET_CHANGED(q)     _PROP3D_REVERB_SET_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_DISTDELAY_SET_DEFINED(q)  _PROP3D_DISTDELAY_SET_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_DISTQUEUE_SET_DEFINED(q)  _PROP3D_DISTQUEUE_SET_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_WIND_SET_CHANGED(q)       _PROP3D_WIND_SET_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_SCENE_CLEAR_CHANGED(q)    _PROP3D_SCENE_CLEAR_CHANGED((q)->dprops3d)
../objects.h:#define _PROP_REVERB_CLEAR_CHANGED(q)   _PROP3D_REVERB_CLEAR_CHANGED(((q)->dprops3d)
../objects.h:#define _PROP_DISTDELAY_CLEAR_DEFINED(q) _PROP3D_DISTDELAY_CLEAR_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_DISTQUEUE_CLEAR_DEFINED(q) _PROP3D_DISTQUEUE_CLEAR_DEFINED((q)->dprops3d)
../objects.h:#define _PROP_WIND_CLEAR_CHANGED(q)     _PROP3D_WIND_CLEAR_CHANGED((q)->dprops3d
../objects.h:      /* pos[0] position; -1.0 left,  0.0 center, 1.0 right */
../objects.h:      /* pos[1] position; -1.0 down,  0.0 center, 1.0 up    */
../objects.h:      /* pos[2] position; -1.0 front, 0.0 center, 1.0 back  */
../ringbuffer.h: * Copyright 2005-2014 by Erik Hofman.
../ringbuffer.h: * Copyright 2009-2014 by Adalin B.V.
../ringbuffer.h:#define ENVELOPE_FOLLOW_STEP_CVT(a)	_MINMAX(-0.1005f+powf((a), 0.25f)/3.15f, 0.0f, 1.0f)
../ringbuffer.h: * From the outside tingbuffer audio data is always 24-bit 32-bit aligned,
../ringbuffer.h: * returns an array of pointers that locate the non-interleaved tracks.
../ringbuffer.h: * @param ctr update-rate counter:
../ringbuffer.h: *     - Rendering to the destination buffer is done every frame at the
../ringbuffer.h: * @param ch channel to use from the source buffer if it is multi-channel
../ringbuffer.h: * @param ctr update-rate counter:
../ringbuffer.h: *     - Rendering to the destination buffer is done every frame at the
../ringbuffer.h: * Set a single floating-point ringbuffer parameter
../ringbuffer.h: * Get the value of a floating-point ringbuffer parameter
../ringbuffer.h: * @param lfo optional gain-envelope information, NULL if unused
../ringbuffer.h: * @param dc duty-cycle of the noise.
../ringbuffer.h: * @param skip 0 for non-static and 100 for highly static noise
