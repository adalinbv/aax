/*
 * Copyright 2015-2016 by Adalin B.V.
 * All Rights Reserved.
 *
 * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Adalin B.V.;
 * the contents of this file may not be disclosed to third parties, copied or
 * duplicated in any form, in whole or in part, without the prior written
 * permission of Adalin B.V.
 */

#ifndef AEONWAVE
#define AEONWAVE 1

#include <aax/aax.h>

namespace AAX
{

class AeonWave
{
public:
    AeonWave(const char* n, enum aaxRenderMode m=AAX_MODE_WRITE_STEREO) :
        _c(aaxDriverOpenByName(n,m)),
        _ec(0)
    { _e[0] = _e[1] = _e[2] = 0; }

    AeonWave(enum aaxRenderMode m=AAX_MODE_WRITE_STEREO) : AeonWave(0,m) {}

    ~AeonWave() {
        aaxClose(_c); aaxDestory(_c); _c = 0;
    }

    inline bool close() {
        return aaxDriverClose(_c) ? ((_c=0) != true) : false;
    }
    inline const char* get(enum aaxSetupType t) {
        return aaxDriverGetSetup(_c,t);
    }
    inline bool get(enum aaxRenderMode m) {
        return aaxDriverGetSupport(_c,m);
    }
    inline bool supports(const char* fe) {
        return aaxIsFilterSupported(_c,fe) ? true : aaxIsEffectSupported(_c,fe);
    }

    // mixer
    inline bool set(enum aaxSetupType t, unsigned int s) {
        return aaxMixerSetSetup(_c,t,s);
    }
    inline unsigned int get(enum aaxSetupType t) {
        return aaxMixerGetSetup(_c,t);
    }

    inline bool set(enum aaxState s) {
        return aaxMixerSetState(_x,s);
    }
    inline enum aaxState get() {
        return aaxState(aaxMixerGetState(_c));
    }

    inline bool set(aaxFilter f) {
        return aaxMixerSetFilter(_c,f);
    }
    inline const aaxFilter get(enum aaxFilterType t) {
        return aaxMixerGetFilter(_c,t);
    }
    inline bool set(aaxEffect e) {
        return aaxMixerSetEffect(_c,e);
    }
    inline const aaxEffect get(enum aaxEffectType t) {
        return aaxMixerGetEffect(_c,t);
    }

    inline bool add(const aaxEmitter e) {
        return aaxMixerRegisterEmitter(_c,e);
    }
    inline bool remove(const aaxEmitter e) {
        return aaxMixerDeRegisterEmitter(_c,e);
    }
    inline bool add(const aaxFrame f) {
        return aaxMixerRegisterAudioFrame(_c,f);
    }
    inline bool remove(const aaxFrame f) {
        return aaxMixerDeRegisterAudioFrame(_c,f);
    }
    inline bool add(const aaxConfig s) {
        return aaxMixerRegisterSensor(_c,s);
    }
    inline bool remove(const aaxConfig s) {
        return aaxMixerDeRegisterSensor(_c,s);
    }

    // sensor
    inline bool set(const aaxMtx4f m) {
        return aaxSensorSetMatrix(_c,m);
    }
    inline bool get(aaxMtx4f m) {
        return aaxSensorGetMatrix(_c,m);
    }
    inline bool set(const aaxVec3f v) {
        return aaxSensorSetVelocity(_c,v);
    }
    inline bool get(aaxVec3f v) {
        return aaxSensorSetVelocity(_c,v);
    }
    inline bool sensor(enum aaxState s) {
        return aaxSensorSetState(_c,s);
    }
    inline bool wait(float t) {
        return aaxSensorWaitForBuffer(_x, t);
    }
    inline aaxBuffer buffer() {
        return aaxSensorGetBuffer(_c);
    }
    inline float offset(enum aaxType t) {
        return aaxSensorGetOffset(_c,t);
    }

    // scenery
    inline bool scenery(aaxFilter f) {
        return aaxScenerySetFilter(_c,f);
    }
    inline const aaxFilter scenery(enum aaxFilterType t) {
        return aaxMixerGetFilter(_c,t);
    }
    inline bool scenery(aaxEffect e) {
        return aaxScenerySetEffect(_c,e);
    }
    inline const aaxEffect scenery(enum aaxEffectType t) {
        return aaxMixerGetEffect(_c,t);
    }

    // enumeration
    inline const char* driver(enum aaxRenderMode m=AAX_WRITE_STEREO) {
        aaxDriverClose(_ec); aaxDriverDestroy(_ec); _em = m; _e[1] = 0;
        while (_e[0] < aaxDriverGetCount(_em)) {
            _ec = aaxDriverGetByPos(_e[0]++,_em);
        }
        return aaxDriverGetSetup(_ec,AAX_DRIVER_STRING);
    }
    inline const char* device() { _e[2] = 0;
        while (_e[1] < aaxDriverGetDeviceCount(_ec,_em)) {
            _ed = aaxDriverGetDeviceNameByPos(_ec,_e[1]++,_em);
        }
        return _ed;
    }
    inline const char* interface() {
        const char *ifs = 0;
        while (_e[2] < aaxDriverGetInterfaceCount(_ec,_ed,_em)) {
            ifs = aaxDriverGetInterfaceNameByPos(_ec,_ed,_e[2]++,_em);
        }
        return ifs;
    }
    inline void finish_enumeration() {
        aaxDriverClose(_ec); aaxDriverDestroy(_ec); _e[0] = _e[1] = _e[2] = 0;
    }

    // support
    inline const char* version() {
        return aaxGetversionString(_c);
    }
    static inline unsigned major_version() {
        return aaxGetMajorversion();
    }
    static inline unsigned minor_version() {
        return aaxGetMinorversion();
    }
    static inline unsigned int patch_level() {
        return aaxGetPatchLevel();
    }
    static inline enum aaxErrorType error_no() {
        return aaxGetErrorNo();
    }
    static inline const char* error(enum aaxErrorType e=aaxGetErrorNo()) {
        return aaxGetErrorString(e);
    }


    inline aaxConfig config() {
        return _c;
    }

private:
    aaxConfig _c;

    // enumeration
    enum aaxRenderMode _em;
    unsigned int _e[3];
    const char* _ed;
    aaxConfig _ec;
};

class dsp
{
public:
    dsp(aeonwave a, enum aaxFilterType f) :
        _e(0), _f(aaxFilterCreate(a.config(),f)) {}
    dsp(aeonwave a, enum aaxEffectType e) :
        _f(0), _e(aaxEffectCreate(a.config(),e)) {}
    ~dsp() {
        if (_f) aaxFilterDestroy(_f);
        else aaxEffectDestroy(_e);
    }

    inline bool set(int s) {
        if (_f) return aaxFilterSetState(_f,s);
        else return aaxEffectSetState(_e,s);
    }
    inline int get() {
        if (_f) return aaxFilterGetState(_f);
        else aaxEffectGetState(_e);
    }
    inline bool set(unsigned s, int t, float p, float q, float r, float s) {
        if (_f) return aaxFilterSetSlot(_f,s,t,p,q,r,s);
        else return aaxEffectSetSlot(_e,s,t,p,q,r,s);
    }
    inline bool get(unsigned s, int t, float* p, float* q, float* r, float* s) {
        if (_f) aaxFilterGetSlot(_f,s,t,p,q,r,s);
        else aaxEffectGetSlot(_e,s,t,p,q,r,s);
    }
    inline bool set(unsigned s, int t, aaxVec4f v) {
        if (_f) return aaxFilterSetSlotParams(_f,s,t,v); 
        else return aaxEffectSetSlotParams(_e,s,t,v);
    }
    inline bool get(unsigned s, int t, aaxVec4f v) {
        if (_f) return aaxFilterGetSlotParams(_f,s,t,v);
        else return aaxEffectGetSlotParams(_e,s,t,v);
    }
    inline bool set(int p, int t, float v) {
        if (_f) return aaxFilterSetParam(_f,p,t,v);
        else return  aaxEffectSetParam(_e,p,t,v);
    }
    inline float get(int p, int t) {
        if (_f) return aaxFilterGetParam(_f,p,t);
        else return  aaxEffectGetParam(_e,p,t);
    }

private:
    aaxFilter _f;
    aaxEffect _e;
};

}

#endif

