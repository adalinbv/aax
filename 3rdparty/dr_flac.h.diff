--- /tmp/dr_flac.h	2018-05-03 14:01:11.094789793 +0200
+++ dr_flac.h	2018-05-03 14:01:53.434058700 +0200
@@ -118,8 +118,14 @@
 #ifndef dr_flac_h
 #define dr_flac_h
 
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include <stddef.h>
 
+#include <arch.h>
+
 #if defined(_MSC_VER) && _MSC_VER < 1600
 typedef   signed char    drflac_int8;
 typedef unsigned char    drflac_uint8;
@@ -846,7 +852,7 @@
 #define DRFLAC_INLINE __forceinline
 #else
 #ifdef __GNUC__
-#define DRFLAC_INLINE inline __attribute__((always_inline))
+#define DRFLAC_INLINE inline
 #else
 #define DRFLAC_INLINE inline
 #endif
@@ -900,6 +906,7 @@
 
 
 //// Endian Management ////
+#if 0
 static DRFLAC_INLINE drflac_bool32 drflac__is_little_endian()
 {
 #if defined(DRFLAC_X86) || defined(DRFLAC_X64)
@@ -909,7 +916,9 @@
     return (*(char*)&n) == 1;
 #endif
 }
+#endif
 
+#if 0
 static DRFLAC_INLINE drflac_uint16 drflac__swap_endian_uint16(drflac_uint16 n)
 {
 #ifdef DRFLAC_HAS_BYTESWAP_INTRINSIC
@@ -925,7 +934,9 @@
            ((n & 0x00FF) << 8);
 #endif
 }
+#endif
 
+#if 0
 static DRFLAC_INLINE drflac_uint32 drflac__swap_endian_uint32(drflac_uint32 n)
 {
 #ifdef DRFLAC_HAS_BYTESWAP_INTRINSIC
@@ -943,7 +954,9 @@
            ((n & 0x000000FF) << 24);
 #endif
 }
+#endif
 
+#if 0
 static DRFLAC_INLINE drflac_uint64 drflac__swap_endian_uint64(drflac_uint64 n)
 {
 #ifdef DRFLAC_HAS_BYTESWAP_INTRINSIC
@@ -965,7 +978,7 @@
            ((n & (drflac_uint64)0x00000000000000FF) << 56);
 #endif
 }
-
+#endif
 
 static DRFLAC_INLINE drflac_uint16 drflac__be2host_16(drflac_uint16 n)
 {
@@ -1035,6 +1048,7 @@
 
 
 // The CRC code below is based on this document: http://zlib.net/crc_v3.txt
+#if 0
 static drflac_uint8 drflac__crc8_table[] = {
     0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15, 0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D,
     0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65, 0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D,
@@ -1053,7 +1067,9 @@
     0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB, 0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83,
     0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB, 0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3
 };
+#endif
 
+#if 0
 static drflac_uint16 drflac__crc16_table[] = {
     0x0000, 0x8005, 0x800F, 0x000A, 0x801B, 0x001E, 0x0014, 0x8011,
     0x8033, 0x0036, 0x003C, 0x8039, 0x0028, 0x802D, 0x8027, 0x0022,
@@ -1088,11 +1104,14 @@
     0x0220, 0x8225, 0x822F, 0x022A, 0x823B, 0x023E, 0x0234, 0x8231,
     0x8213, 0x0216, 0x021C, 0x8219, 0x0208, 0x820D, 0x8207, 0x0202
 };
+#endif
 
+#if 0
 static DRFLAC_INLINE drflac_uint8 drflac_crc8_byte(drflac_uint8 crc, drflac_uint8 data)
 {
     return drflac__crc8_table[crc ^ data];
 }
+#endif
 
 static DRFLAC_INLINE drflac_uint8 drflac_crc8(drflac_uint8 crc, drflac_uint32 data, drflac_uint32 count)
 {
@@ -1137,11 +1156,14 @@
 #endif
 }
 
+#if 0
 static DRFLAC_INLINE drflac_uint16 drflac_crc16_byte(drflac_uint16 crc, drflac_uint8 data)
 {
     return (crc << 8) ^ drflac__crc16_table[(drflac_uint8)(crc >> 8) ^ data];
 }
+#endif
 
+#if 0
 static DRFLAC_INLINE drflac_uint16 drflac_crc16_bytes(drflac_uint16 crc, drflac_cache_t data, drflac_uint32 byteCount)
 {
     switch (byteCount)
@@ -1160,7 +1182,9 @@
 
     return crc;
 }
+#endif
 
+#if 0
 static DRFLAC_INLINE drflac_uint16 drflac_crc16__32bit(drflac_uint16 crc, drflac_uint32 data, drflac_uint32 count)
 {
     drflac_assert(count <= 64);
@@ -1205,7 +1229,9 @@
 #endif
 #endif
 }
+#endif
 
+#if 0
 static DRFLAC_INLINE drflac_uint16 drflac_crc16__64bit(drflac_uint16 crc, drflac_uint64 data, drflac_uint32 count)
 {
     drflac_assert(count <= 64);
@@ -1239,8 +1265,9 @@
     return crc;
 #endif
 }
+#endif
 
-
+#if 0
 static DRFLAC_INLINE drflac_uint16 drflac_crc16(drflac_uint16 crc, drflac_cache_t data, drflac_uint32 count)
 {
 #ifdef DRFLAC_64BIT
@@ -1249,6 +1276,7 @@
     return drflac_crc16__32bit(crc, data, count);
 #endif
 }
+#endif
 
 
 #ifdef DRFLAC_64BIT
